searchNodes=[{"doc":"Explorer brings series (one-dimensional) and dataframes (two-dimensional) for fast data exploration to Elixir. Getting started Inside an Elixir script or Livebook : Mix . install ( [ { :explorer , &quot;~&gt; 0.5.0&quot; } ] ) Or in the mix.exs file of your application: def deps do [ { :explorer , &quot;~&gt; 0.5.0&quot; } ] end A glimpse of the API We have two ways to represent data with Explorer: using a series, that is similar to a list, but is guaranteed to contain items of one data type only - or one dtype for short. Notice that nil values are permitted in series of any dtype. using a dataframe, that is just a way to represent one or more series together, and work with them as a whole. The only restriction is that all the series shares the same size. A series can be created from a list: fruits = Explorer.Series . from_list ( [ &quot;apple&quot; , &quot;mango&quot; , &quot;banana&quot; , &quot;orange&quot; ] ) Your newly created series is going to look like: # Explorer.Series &lt; Polars [ 4 ] string [ &quot;apple&quot; , &quot;mango&quot; , &quot;banana&quot; , &quot;orange&quot; ] &gt; And you can, for example, sort that series: Explorer.Series . sort ( fruits ) Resulting in the following: # Explorer.Series &lt; Polars [ 4 ] string [ &quot;apple&quot; , &quot;banana&quot; , &quot;mango&quot; , &quot;orange&quot; ] &gt; Dataframes Dataframes can be created in two ways: by reading from files or memory using the IO functions . This is by far the most common way to load dataframes in Explorer. We accept Parquet, IPC, CSV, and NDJSON files. by using the Explorer.DataFrame.new/2 function, that is neat for small experiments. We are going to use this function here. You can pass either series or lists to it: mountains = Explorer.DataFrame . new ( name : [ &quot;Everest&quot; , &quot;K2&quot; , &quot;Aconcagua&quot; ] , elevation : [ 8848 , 8611 , 6962 ] ) Your dataframe is going to look like this: # Explorer.DataFrame &lt; Polars [ 3 x 2 ] name string [ &quot;Everest&quot; , &quot;K2&quot; , &quot;Aconcagua&quot; ] elevation integer [ 8848 , 8611 , 6962 ] &gt; It's also possible to see a dataframe like a table, using the Explorer.DataFrame.table/2 function: Explorer.DataFrame . table ( mountains ) Prints: + -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - + | Explorer DataFrame : [ rows : 3 , columns : 2 ] | + -- -- -- -- -- -- -- -- -- -- - + -- -- -- -- -- -- -- -- -- -- - + | name | elevation | | &lt; string &gt; | &lt; integer &gt; | + === === === === === === === + === === === === === === === + | Everest | 8848 | + -- -- -- -- -- -- -- -- -- -- - + -- -- -- -- -- -- -- -- -- -- - + | K2 | 8611 | + -- -- -- -- -- -- -- -- -- -- - + -- -- -- -- -- -- -- -- -- -- - + | Aconcagua | 6962 | + -- -- -- -- -- -- -- -- -- -- - + -- -- -- -- -- -- -- -- -- -- - + And now I want to show you how to filter our dataframe. But first, let's require the Explorer.DataFrame module and give a short name to it: require Explorer.DataFrame , as : DF The &quot;require&quot; is needed to load the macro features of that module. We give it a shorter name to simplify our examples. Now let's go to the filter. I want to filter the mountains that are above the mean elevation in our dataframe: DF . filter ( mountains , elevation &gt; mean ( elevation ) ) You can see that we can refer to the columns using their names, and use functions without define them. This is possible due the powerful Explorer.Query features, and it's the main reason we need to &quot;require&quot; the Explorer.DataFrame module. The result is going to look like this: # Explorer.DataFrame &lt; Polars [ 2 x 2 ] name string [ &quot;Everest&quot; , &quot;K2&quot; ] elevation integer [ 8848 , 8611 ] &gt; There is an extensive guide that you can play with Livebook: Ten Minutes to Explorer You can also check the Explorer.DataFrame and Explorer.Series docs for further details. Features and design Explorer high-level features are: Simply typed series: :binary , :boolean , :category , :date , :datetime , :float , :integer , :string , and :time . A powerful but constrained and opinionated API, so you spend less time looking for the right function and more time doing data manipulation. Pluggable backends, providing a uniform API whether you're working in-memory or (forthcoming) on remote databases or even Spark dataframes. The first (and default) backend is based on NIF bindings to the blazing-fast polars library. The API is heavily influenced by Tidy Data and borrows much of its design from dplyr . The philosophy is heavily influenced by this passage from dplyr 's documentation: By constraining your options, it helps you think about your data manipulation challenges. It provides simple “verbs”, functions that correspond to the most common data manipulation tasks, to help you translate your thoughts into code. It uses efficient backends, so you spend less time waiting for the computer. The aim here isn't to have the fastest dataframe library around (though it certainly helps that we're building on Polars, one of the fastest ). Instead, we're aiming to bridge the best of many worlds: the elegance of dplyr the speed of polars the joy of Elixir That means you can expect the guiding principles to be 'Elixir-ish'. For example, you won't see the underlying data mutated, even if that's the most efficient implementation. Explorer functions will always return a new dataframe or series.","ref":"Explorer.html","title":"Explorer","type":"module"},{"doc":"The DataFrame struct and API. Dataframes are two-dimensional tabular data structures similar to a spreadsheet. For example, the Iris dataset: iex&gt; Explorer.Datasets . iris ( ) # Explorer.DataFrame &lt; Polars [ 150 x 5 ] sepal_length float [ 5.1 , 4.9 , 4.7 , 4.6 , 5.0 , ... ] sepal_width float [ 3.5 , 3.0 , 3.2 , 3.1 , 3.6 , ... ] petal_length float [ 1.4 , 1.4 , 1.3 , 1.5 , 1.4 , ... ] petal_width float [ 0.2 , 0.2 , 0.2 , 0.2 , 0.2 , ... ] species string [ &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , ... ] &gt; This dataframe has 150 rows and five columns. Each column is an Explorer.Series of the same size (150): iex&gt; df = Explorer.Datasets . iris ( ) iex&gt; df [ &quot;sepal_length&quot; ] # Explorer.Series &lt; Polars [ 150 ] float [ 5.1 , 4.9 , 4.7 , 4.6 , 5.0 , 5.4 , 4.6 , 5.0 , 4.4 , 4.9 , 5.4 , 4.8 , 4.8 , 4.3 , 5.8 , 5.7 , 5.4 , 5.1 , 5.7 , 5.1 , 5.4 , 5.1 , 4.6 , 5.1 , 4.8 , 5.0 , 5.0 , 5.2 , 5.2 , 4.7 , 4.8 , 5.4 , 5.2 , 5.5 , 4.9 , 5.0 , 5.5 , 4.9 , 4.4 , 5.1 , 5.0 , 4.5 , 4.4 , 5.0 , 5.1 , 4.8 , 5.1 , 4.6 , 5.3 , 5.0 , ... ] &gt; Creating dataframes Dataframes can be created from normal Elixir objects. The main way you might do this is with the new/1 function. For example: iex&gt; Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; ] , b : [ 1 , 2 ] ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] a string [ &quot;a&quot; , &quot;b&quot; ] b integer [ 1 , 2 ] &gt; Or with a list of maps: iex&gt; Explorer.DataFrame . new ( [ %{ &quot;col1&quot; =&gt; &quot;a&quot; , &quot;col2&quot; =&gt; 1 } , %{ &quot;col1&quot; =&gt; &quot;b&quot; , &quot;col2&quot; =&gt; 2 } ] ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] col1 string [ &quot;a&quot; , &quot;b&quot; ] col2 integer [ 1 , 2 ] &gt; Verbs Explorer uses the idea of a consistent set of SQL-like verbs like dplyr which can help solve common data manipulation challenges. These are split into single table verbs, multiple table verbs, and row-based verbs: Single table verbs Single table verbs are (unsurprisingly) used for manipulating a single dataframe. Those operations typically driven by column names. These are: select/2 for picking columns and discard/2 to discard them filter/2 for picking rows based on predicates mutate/2 for adding or replacing columns that are functions of existing columns arrange/2 for changing the ordering of rows distinct/2 for picking unique rows summarise/2 for reducing multiple rows down to a single summary pivot_longer/3 and pivot_wider/4 for massaging dataframes into longer or wider forms, respectively Each of these combine with Explorer.DataFrame.group_by/2 for operating by group. Multiple table verbs Multiple table verbs are used for combining tables. These are: join/3 for performing SQL-like joins concat_columns/1 for horizontally &quot;stacking&quot; dataframes concat_rows/1 for vertically &quot;stacking&quot; dataframes Row-based verbs Those operations are driven by the row index. These are: head/2 for picking the first rows tail/2 for picking the last rows slice/2 for slicing the dataframe by row indexes or a range slice/3 for slicing a section by an offset sample/2 for sampling the data-frame by row IO operations Explorer supports reading and writing of: delimited files (such as CSV) Parquet Arrow IPC Arrow Streaming IPC Newline Delimited JSON The convention Explorer uses is to have from_* and to_* functions to read and write to files in the formats above. load_* and dump_* versions are also available to read and write those formats directly in memory. Selecting columns and access Several functions in this module, such as select/2 , discard/2 , drop_nil/2 , and so forth accept a single or multiple columns as arguments. The columns can be specified in a variety of formats, which we describe below. Explorer.DataFrame also implements the Access behaviour (also known as the brackets syntax). This should be familiar for users coming from other language with dataframes such as R or Python. For example: iex&gt; df = Explorer.Datasets . wine ( ) iex&gt; df [ &quot;class&quot; ] # Explorer.Series &lt; Polars [ 178 ] integer [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , ... ] &gt; Accessing the dataframe with a column name either as a string or an atom, will return the column. You can also pass an integer representing the column order: iex&gt; df = Explorer.Datasets . wine ( ) iex&gt; df [ 0 ] # Explorer.Series &lt; Polars [ 178 ] integer [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , ... ] &gt; You can also pass a list, a range, or a regex to return a dataframe matching the given data type. For example, by passing a list: iex&gt; df = Explorer.Datasets . wine ( ) iex&gt; df [ [ &quot;class&quot; , &quot;hue&quot; ] ] # Explorer.DataFrame &lt; Polars [ 178 x 2 ] class integer [ 1 , 1 , 1 , 1 , 1 , ... ] hue float [ 1.04 , 1.05 , 1.03 , 0.86 , 1.04 , ... ] &gt; Or a range for the given positions: iex&gt; df = Explorer.Datasets . wine ( ) iex&gt; df [ 0 .. 2 ] # Explorer.DataFrame &lt; Polars [ 178 x 3 ] class integer [ 1 , 1 , 1 , 1 , 1 , ... ] alcohol float [ 14.23 , 13.2 , 13.16 , 14.37 , 13.24 , ... ] malic_acid float [ 1.71 , 1.78 , 2.36 , 1.95 , 2.59 , ... ] &gt; Or a regex to keep only columns matching a given pattern: iex&gt; df = Explorer.Datasets . wine ( ) iex&gt; df [ ~r/(class|hue)/ ] # Explorer.DataFrame &lt; Polars [ 178 x 2 ] class integer [ 1 , 1 , 1 , 1 , 1 , ... ] hue float [ 1.04 , 1.05 , 1.03 , 0.86 , 1.04 , ... ] &gt; Given you can also access a series using its index, you can use multiple accesses to select a column and row at the same time: iex&gt; df = Explorer.Datasets . wine ( ) iex&gt; df [ &quot;class&quot; ] [ 3 ] 1","ref":"Explorer.DataFrame.html","title":"Explorer.DataFrame","type":"module"},{"doc":"Arranges/sorts rows by columns using Explorer.Query . Notice This is a macro. You must require Explorer.DataFrame before using it. See arrange_with/2 for a callback version of this function without Explorer.Query . Examples A single column name will sort ascending by that column: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;b&quot; , &quot;c&quot; , &quot;a&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . arrange ( df , a ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] b integer [ 3 , 1 , 2 ] &gt; You can also sort descending: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;b&quot; , &quot;c&quot; , &quot;a&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . arrange ( df , desc : a ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] a string [ &quot;c&quot; , &quot;b&quot; , &quot;a&quot; ] b integer [ 2 , 1 , 3 ] &gt; Sorting by more than one column sorts them in the order they are entered: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . arrange ( df , asc : total , desc : country ) # Explorer.DataFrame &lt; Polars [ 1094 x 10 ] year integer [ 2010 , 2010 , 2011 , 2011 , 2012 , ... ] country string [ &quot;NIUE&quot; , &quot;TUVALU&quot; , &quot;TUVALU&quot; , &quot;NIUE&quot; , &quot;NIUE&quot; , ... ] total integer [ 1 , 2 , 2 , 2 , 2 , ... ] solid_fuel integer [ 0 , 0 , 0 , 0 , 0 , ... ] liquid_fuel integer [ 1 , 2 , 2 , 2 , 2 , ... ] gas_fuel integer [ 0 , 0 , 0 , 0 , 0 , ... ] cement integer [ 0 , 0 , 0 , 0 , 0 , ... ] gas_flaring integer [ 0 , 0 , 0 , 0 , 0 , ... ] per_capita float [ 0.52 , 0.0 , 0.0 , 1.04 , 1.04 , ... ] bunker_fuels integer [ 0 , 0 , 0 , 0 , 0 , ... ] &gt; Grouped examples When used in a grouped dataframe, arrange is going to sort each group individually and then return the entire dataframe with the existing groups. If one of the arrange columns is also a group, the sorting for that column is not going to work. It is necessary to first summarise the desired column and then arrange it. Here is an example using the Iris dataset. We group by species and then we try to sort the dataframe by species and petal length, but only &quot;petal length&quot; is taken into account because &quot;species&quot; is a group. iex&gt; df = Explorer.Datasets . iris ( ) iex&gt; grouped = Explorer.DataFrame . group_by ( df , &quot;species&quot; ) iex&gt; Explorer.DataFrame . arrange ( grouped , desc : species , asc : sepal_width ) # Explorer.DataFrame &lt; Polars [ 150 x 5 ] Groups : [ &quot;species&quot; ] sepal_length float [ 4.5 , 4.4 , 4.9 , 4.8 , 4.3 , ... ] sepal_width float [ 2.3 , 2.9 , 3.0 , 3.0 , 3.0 , ... ] petal_length float [ 1.3 , 1.4 , 1.4 , 1.4 , 1.1 , ... ] petal_width float [ 0.3 , 0.2 , 0.2 , 0.1 , 0.1 , ... ] species string [ &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , ... ] &gt;","ref":"Explorer.DataFrame.html#arrange/2","title":"Explorer.DataFrame.arrange/2","type":"macro"},{"doc":"Arranges/sorts rows by columns using a callback function. The callback receives a lazy dataframe. A lazy dataframe does hold any values, instead it stores all operations in order to execute all sorting performantly. This is a callback version of arrange/2 . Sorting is stable by default. Examples A single column name will sort ascending by that column: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;b&quot; , &quot;c&quot; , &quot;a&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . arrange_with ( df , &amp; ( &amp;1 [ &quot;a&quot; ] ) ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] b integer [ 3 , 1 , 2 ] &gt; You can also sort descending: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;b&quot; , &quot;c&quot; , &quot;a&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . arrange_with ( df , &amp; [ desc : &amp;1 [ &quot;a&quot; ] ] ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] a string [ &quot;c&quot; , &quot;b&quot; , &quot;a&quot; ] b integer [ 2 , 1 , 3 ] &gt; Sorting by more than one column sorts them in the order they are entered: iex&gt; df = Explorer.DataFrame . new ( a : [ 3 , 1 , 3 ] , b : [ 2 , 1 , 3 ] ) iex&gt; Explorer.DataFrame . arrange_with ( df , &amp; [ desc : &amp;1 [ &quot;a&quot; ] , asc : &amp;1 [ &quot;b&quot; ] ] ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] a integer [ 3 , 3 , 1 ] b integer [ 2 , 3 , 1 ] &gt; Grouped examples iex&gt; df = Explorer.Datasets . iris ( ) iex&gt; grouped = Explorer.DataFrame . group_by ( df , &quot;species&quot; ) iex&gt; Explorer.DataFrame . arrange_with ( grouped , &amp; [ desc : &amp;1 [ &quot;species&quot; ] , asc : &amp;1 [ &quot;sepal_width&quot; ] ] ) # Explorer.DataFrame &lt; Polars [ 150 x 5 ] Groups : [ &quot;species&quot; ] sepal_length float [ 4.5 , 4.4 , 4.9 , 4.8 , 4.3 , ... ] sepal_width float [ 2.3 , 2.9 , 3.0 , 3.0 , 3.0 , ... ] petal_length float [ 1.3 , 1.4 , 1.4 , 1.4 , 1.1 , ... ] petal_width float [ 0.3 , 0.2 , 0.2 , 0.1 , 0.1 , ... ] species string [ &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , ... ] &gt;","ref":"Explorer.DataFrame.html#arrange_with/2","title":"Explorer.DataFrame.arrange_with/2","type":"function"},{"doc":"This collects the lazy data frame into an eager one, computing the query. If already eager, this is a noop. Collecting a grouped dataframe should return a grouped dataframe.","ref":"Explorer.DataFrame.html#collect/1","title":"Explorer.DataFrame.collect/1","type":"function"},{"doc":"Combine two or more dataframes column-wise. This function expects the dataframes to have the same number of rows, otherwise rows may be silently discarded. Eager backends may check whenever this happens and raise instead of silently fail. But this may not be possible for lazy dataframes as the number of rows is not known upfront. When working with grouped dataframes, be aware that only groups from the first dataframe are kept in the resultant dataframe. Examples iex&gt; df1 = Explorer.DataFrame . new ( x : [ 1 , 2 , 3 ] , y : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; df2 = Explorer.DataFrame . new ( z : [ 4 , 5 , 6 ] , a : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] ) iex&gt; Explorer.DataFrame . concat_columns ( [ df1 , df2 ] ) # Explorer.DataFrame &lt; Polars [ 3 x 4 ] x integer [ 1 , 2 , 3 ] y string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] z integer [ 4 , 5 , 6 ] a string [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] &gt; Conflicting names are suffixed with the index of the dataframe in the array: iex&gt; df1 = Explorer.DataFrame . new ( x : [ 1 , 2 , 3 ] , y : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; df2 = Explorer.DataFrame . new ( x : [ 4 , 5 , 6 ] , a : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] ) iex&gt; Explorer.DataFrame . concat_columns ( [ df1 , df2 ] ) # Explorer.DataFrame &lt; Polars [ 3 x 4 ] x integer [ 1 , 2 , 3 ] y string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] x_1 integer [ 4 , 5 , 6 ] a string [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] &gt;","ref":"Explorer.DataFrame.html#concat_columns/1","title":"Explorer.DataFrame.concat_columns/1","type":"function"},{"doc":"Combine two dataframes column-wise. When working with grouped dataframes, be aware that only groups from the left-hand side dataframe are kept in the resultant dataframe. concat_columns(df1, df2) is equivalent to concat_columns([df1, df2]) .","ref":"Explorer.DataFrame.html#concat_columns/2","title":"Explorer.DataFrame.concat_columns/2","type":"function"},{"doc":"Combine two or more dataframes row-wise (stack). Column names and dtypes must match. The only exception is for numeric columns that can be mixed together, and casted automatically to float columns. When working with grouped dataframes, be aware that only groups from the first dataframe are kept in the resultant dataframe. Examples iex&gt; df1 = Explorer.DataFrame . new ( x : [ 1 , 2 , 3 ] , y : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; df2 = Explorer.DataFrame . new ( x : [ 4 , 5 , 6 ] , y : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] ) iex&gt; Explorer.DataFrame . concat_rows ( [ df1 , df2 ] ) # Explorer.DataFrame &lt; Polars [ 6 x 2 ] x integer [ 1 , 2 , 3 , 4 , 5 , ... ] y string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; , &quot;d&quot; , &quot;e&quot; , ... ] &gt; iex&gt; df1 = Explorer.DataFrame . new ( x : [ 1 , 2 , 3 ] , y : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; df2 = Explorer.DataFrame . new ( x : [ 4.2 , 5.3 , 6.4 ] , y : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] ) iex&gt; Explorer.DataFrame . concat_rows ( [ df1 , df2 ] ) # Explorer.DataFrame &lt; Polars [ 6 x 2 ] x float [ 1.0 , 2.0 , 3.0 , 4.2 , 5.3 , ... ] y string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; , &quot;d&quot; , &quot;e&quot; , ... ] &gt;","ref":"Explorer.DataFrame.html#concat_rows/1","title":"Explorer.DataFrame.concat_rows/1","type":"function"},{"doc":"Combine two dataframes row-wise. concat_rows(df1, df2) is equivalent to concat_rows([df1, df2]) . When working with grouped dataframes, be aware that only groups from the left-hand side dataframe are kept in the resultant dataframe.","ref":"Explorer.DataFrame.html#concat_rows/2","title":"Explorer.DataFrame.concat_rows/2","type":"function"},{"doc":"Describe numeric columns of a DataFrame. Groups are ignored if the dataframe is using any. Options :percentiles - Floating point list with the percentiles to be calculated. (default: [0.25, 0.5, 0.75] ) Examples iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;d&quot; , nil , &quot;f&quot; ] , b : [ 1 , 2 , 3 ] , c : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.DataFrame . describe ( df ) # Explorer.DataFrame &lt; Polars [ 9 x 4 ] describe string [ &quot;count&quot; , &quot;null_count&quot; , &quot;mean&quot; , &quot;std&quot; , &quot;min&quot; , ... ] a string [ &quot;3&quot; , &quot;1&quot; , nil , nil , &quot;d&quot; , ... ] b float [ 3.0 , 0.0 , 2.0 , 1.0 , 1.0 , ... ] c string [ &quot;3&quot; , &quot;0&quot; , nil , nil , &quot;a&quot; , ... ] &gt; iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;d&quot; , nil , &quot;f&quot; ] , b : [ 1 , 2 , 3 ] , c : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.DataFrame . describe ( df , percentiles : [ 0.3 , 0.5 , 0.8 ] ) # Explorer.DataFrame &lt; Polars [ 9 x 4 ] describe string [ &quot;count&quot; , &quot;null_count&quot; , &quot;mean&quot; , &quot;std&quot; , &quot;min&quot; , ... ] a string [ &quot;3&quot; , &quot;1&quot; , nil , nil , &quot;d&quot; , ... ] b float [ 3.0 , 0.0 , 2.0 , 1.0 , 1.0 , ... ] c string [ &quot;3&quot; , &quot;0&quot; , nil , nil , &quot;a&quot; , ... ] &gt;","ref":"Explorer.DataFrame.html#describe/2","title":"Explorer.DataFrame.describe/2","type":"function"},{"doc":"Discards a subset of columns by name. It's important to notice that groups are kept: you can't discard grouping columns. Examples iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . discard ( df , [ &quot;b&quot; ] ) # Explorer.DataFrame &lt; Polars [ 3 x 1 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] &gt; iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] , c : [ 4 , 5 , 6 ] ) iex&gt; Explorer.DataFrame . discard ( df , [ &quot;a&quot; , &quot;b&quot; ] ) # Explorer.DataFrame &lt; Polars [ 3 x 1 ] c integer [ 4 , 5 , 6 ] &gt; Ranges, regexes, and functions are also accepted in column names, as in select/2 . Grouped examples You cannot discard grouped columns. You need to ungroup before removing them: iex&gt; df = Explorer.Datasets . iris ( ) iex&gt; grouped = Explorer.DataFrame . group_by ( df , &quot;species&quot; ) iex&gt; Explorer.DataFrame . discard ( grouped , [ &quot;species&quot; ] ) # Explorer.DataFrame &lt; Polars [ 150 x 5 ] Groups : [ &quot;species&quot; ] sepal_length float [ 5.1 , 4.9 , 4.7 , 4.6 , 5.0 , ... ] sepal_width float [ 3.5 , 3.0 , 3.2 , 3.1 , 3.6 , ... ] petal_length float [ 1.4 , 1.4 , 1.3 , 1.5 , 1.4 , ... ] petal_width float [ 0.2 , 0.2 , 0.2 , 0.2 , 0.2 , ... ] species string [ &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , ... ] &gt;","ref":"Explorer.DataFrame.html#discard/2","title":"Explorer.DataFrame.discard/2","type":"function"},{"doc":"Takes distinct rows by a selection of columns. Distinct is not affected by groups, although groups are kept in the columns selection if keep_all option is false (the default). Options :keep_all - If set to true , keep all columns. Default is false . Examples By default will return unique values of the requested columns: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . distinct ( df , [ &quot;year&quot; , &quot;country&quot; ] ) # Explorer.DataFrame &lt; Polars [ 1094 x 2 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , ... ] &gt; If keep_all is set to true , then the first value of each column not in the requested columns will be returned: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . distinct ( df , [ &quot;year&quot; , &quot;country&quot; ] , keep_all : true ) # Explorer.DataFrame &lt; Polars [ 1094 x 10 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , ... ] total integer [ 2308 , 1254 , 32500 , 141 , 7924 , ... ] solid_fuel integer [ 627 , 117 , 332 , 0 , 0 , ... ] liquid_fuel integer [ 1601 , 953 , 12381 , 141 , 3649 , ... ] gas_fuel integer [ 74 , 7 , 14565 , 0 , 374 , ... ] cement integer [ 5 , 177 , 2598 , 0 , 204 , ... ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 , ... ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , ... ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 , ... ] &gt; A callback on the dataframe's names can be passed instead of a list (like select/2 ): iex&gt; df = Explorer.DataFrame . new ( x1 : [ 1 , 3 , 3 ] , x2 : [ &quot;a&quot; , &quot;c&quot; , &quot;c&quot; ] , y1 : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . distinct ( df , &amp; String . starts_with? ( &amp;1 , &quot;x&quot; ) ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] x1 integer [ 1 , 3 ] x2 string [ &quot;a&quot; , &quot;c&quot; ] &gt; If the dataframe has groups, then the columns of each group will be added to the distinct columns: iex&gt; df = Explorer.DataFrame . new ( x1 : [ 1 , 3 , 3 ] , x2 : [ &quot;a&quot; , &quot;c&quot; , &quot;c&quot; ] , y1 : [ 1 , 2 , 3 ] ) iex&gt; df = Explorer.DataFrame . group_by ( df , &quot;x1&quot; ) iex&gt; Explorer.DataFrame . distinct ( df , [ &quot;x2&quot; ] ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] Groups : [ &quot;x1&quot; ] x1 integer [ 1 , 3 ] x2 string [ &quot;a&quot; , &quot;c&quot; ] &gt;","ref":"Explorer.DataFrame.html#distinct/3","title":"Explorer.DataFrame.distinct/3","type":"function"},{"doc":"Drop nil values. Optionally accepts a subset of columns. Examples To drop nils on all columns: iex&gt; df = Explorer.DataFrame . new ( a : [ 1 , 2 , nil ] , b : [ 1 , nil , 3 ] ) iex&gt; Explorer.DataFrame . drop_nil ( df ) # Explorer.DataFrame &lt; Polars [ 1 x 2 ] a integer [ 1 ] b integer [ 1 ] &gt; To drop nils on a single column: iex&gt; df = Explorer.DataFrame . new ( a : [ 1 , 2 , nil ] , b : [ 1 , nil , 3 ] ) iex&gt; Explorer.DataFrame . drop_nil ( df , :a ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] a integer [ 1 , 2 ] b integer [ 1 , nil ] &gt; To drop some columns: iex&gt; df = Explorer.DataFrame . new ( a : [ 1 , 2 , nil ] , b : [ 1 , nil , 3 ] , c : [ nil , 5 , 6 ] ) iex&gt; Explorer.DataFrame . drop_nil ( df , [ :a , :c ] ) # Explorer.DataFrame &lt; Polars [ 1 x 3 ] a integer [ 2 ] b integer [ nil ] c integer [ 5 ] &gt; Ranges, regexes, and functions are also accepted in column names, as in select/2 .","ref":"Explorer.DataFrame.html#drop_nil/2","title":"Explorer.DataFrame.drop_nil/2","type":"function"},{"doc":"Gets the dtypes of the dataframe columns. Examples iex&gt; df = Explorer.DataFrame . new ( floats : [ 1.0 , 2.0 ] , ints : [ 1 , 2 ] ) iex&gt; Explorer.DataFrame . dtypes ( df ) %{ &quot;floats&quot; =&gt; :float , &quot;ints&quot; =&gt; :integer }","ref":"Explorer.DataFrame.html#dtypes/1","title":"Explorer.DataFrame.dtypes/1","type":"function"},{"doc":"Turns a set of columns to dummy variables. In case the dataframe is using groups, all groups will be removed. Examples To mark a single column as dummy: iex&gt; df = Explorer.DataFrame . new ( col_x : [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; , &quot;c&quot; ] , col_y : [ &quot;b&quot; , &quot;a&quot; , &quot;b&quot; , &quot;d&quot; ] ) iex&gt; Explorer.DataFrame . dummies ( df , &quot;col_x&quot; ) # Explorer.DataFrame &lt; Polars [ 4 x 3 ] col_x_a integer [ 1 , 0 , 1 , 0 ] col_x_b integer [ 0 , 1 , 0 , 0 ] col_x_c integer [ 0 , 0 , 0 , 1 ] &gt; Or multiple columns: iex&gt; df = Explorer.DataFrame . new ( col_x : [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; , &quot;c&quot; ] , col_y : [ &quot;b&quot; , &quot;a&quot; , &quot;b&quot; , &quot;d&quot; ] ) iex&gt; Explorer.DataFrame . dummies ( df , [ &quot;col_x&quot; , &quot;col_y&quot; ] ) # Explorer.DataFrame &lt; Polars [ 4 x 6 ] col_x_a integer [ 1 , 0 , 1 , 0 ] col_x_b integer [ 0 , 1 , 0 , 0 ] col_x_c integer [ 0 , 0 , 0 , 1 ] col_y_b integer [ 1 , 0 , 1 , 0 ] col_y_a integer [ 0 , 1 , 0 , 0 ] col_y_d integer [ 0 , 0 , 0 , 1 ] &gt; Or all string columns: iex&gt; df = Explorer.DataFrame . new ( num : [ 1 , 2 , 3 , 4 ] , col_y : [ &quot;b&quot; , &quot;a&quot; , &quot;b&quot; , &quot;d&quot; ] ) iex&gt; Explorer.DataFrame . dummies ( df , fn _name , type -&gt; type == :string end ) # Explorer.DataFrame &lt; Polars [ 4 x 3 ] col_y_b integer [ 1 , 0 , 1 , 0 ] col_y_a integer [ 0 , 1 , 0 , 0 ] col_y_d integer [ 0 , 0 , 0 , 1 ] &gt; Ranges, regexes, and functions are also accepted in column names, as in select/2 .","ref":"Explorer.DataFrame.html#dummies/2","title":"Explorer.DataFrame.dummies/2","type":"function"},{"doc":"Writes a dataframe to a binary representation of a delimited file. Options :header - Should the column names be written as the first line of the file? (default: true ) :delimiter - A single character used to separate fields within a record. (default: &quot;,&quot; ) Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) |&gt; Explorer.DataFrame . head ( 2 ) iex&gt; Explorer.DataFrame . dump_csv ( df ) { :ok , &quot;year,country,total,solid_fuel,liquid_fuel,gas_fuel,cement,gas_flaring,per_capita,bunker_fuels \\n 2010,AFGHANISTAN,2308,627,1601,74,5,0,0.08,9 \\n 2010,ALBANIA,1254,117,953,7,177,0,0.43,7 \\n &quot; }","ref":"Explorer.DataFrame.html#dump_csv/2","title":"Explorer.DataFrame.dump_csv/2","type":"function"},{"doc":"Similar to dump_csv/2 , but raises in case of error.","ref":"Explorer.DataFrame.html#dump_csv!/2","title":"Explorer.DataFrame.dump_csv!/2","type":"function"},{"doc":"Writes a dataframe to a binary representation of an IPC file. Groups are ignored if the dataframe is using any. Options :compression - The compression algorithm to use when writing files. Supported options are: nil (uncompressed, default) :zstd :lz4 .","ref":"Explorer.DataFrame.html#dump_ipc/2","title":"Explorer.DataFrame.dump_ipc/2","type":"function"},{"doc":"Similar to dump_ipc/2 , but raises in case of error.","ref":"Explorer.DataFrame.html#dump_ipc!/2","title":"Explorer.DataFrame.dump_ipc!/2","type":"function"},{"doc":"Writes a dataframe to a binary representation of an IPC Stream file. Groups are ignored if the dataframe is using any. Options :compression - The compression algorithm to use when writing files. Supported options are: nil (uncompressed, default) :zstd :lz4 .","ref":"Explorer.DataFrame.html#dump_ipc_stream/2","title":"Explorer.DataFrame.dump_ipc_stream/2","type":"function"},{"doc":"Similar to dump_ipc_stream/2 , but raises in case of error.","ref":"Explorer.DataFrame.html#dump_ipc_stream!/2","title":"Explorer.DataFrame.dump_ipc_stream!/2","type":"function"},{"doc":"Writes a dataframe to a binary representation of a NDJSON file. Groups are ignored if the dataframe is using any. Examples iex&gt; df = Explorer.DataFrame . new ( col_a : [ 1 , 2 ] , col_b : [ 5.1 , 5.2 ] ) iex&gt; Explorer.DataFrame . dump_ndjson ( df ) { :ok , ~s({&quot;col_a&quot;:1,&quot;col_b&quot;:5.1} \\n {&quot;col_a&quot;:2,&quot;col_b&quot;:5.2} \\n ) }","ref":"Explorer.DataFrame.html#dump_ndjson/1","title":"Explorer.DataFrame.dump_ndjson/1","type":"function"},{"doc":"Similar to dump_ndjson!/2 , but raises in case of error.","ref":"Explorer.DataFrame.html#dump_ndjson!/1","title":"Explorer.DataFrame.dump_ndjson!/1","type":"function"},{"doc":"Writes a dataframe to a binary representation of a Parquet file. Groups are ignored if the dataframe is using any. Options :compression - The compression algorithm to use when writing files. Where a compression level is available, this can be passed as a tuple, such as {:zstd, 3} . Supported options are: nil (uncompressed, default) :snappy :gzip (with levels 1-9) :brotli (with levels 1-11) :zstd (with levels -7-22) :lz4raw .","ref":"Explorer.DataFrame.html#dump_parquet/2","title":"Explorer.DataFrame.dump_parquet/2","type":"function"},{"doc":"Similar to dump_parquet/2 , but raises in case of error.","ref":"Explorer.DataFrame.html#dump_parquet!/2","title":"Explorer.DataFrame.dump_parquet!/2","type":"function"},{"doc":"Picks rows based on Explorer.Query . The query is compiled and runs efficiently against the dataframe. The query must return a boolean expression or a list of boolean expressions. When a list is returned, they are joined as and expressions. Notice This is a macro. You must require Explorer.DataFrame before using it. Besides element-wise series operations, you can also use window functions and aggregations inside comparisons. In such cases, grouped dataframes may have different results than ungrouped ones, because the filtering is computed withing groups. See examples below. See filter_with/2 for a callback version of this function without Explorer.Query . Examples iex&gt; df = Explorer.DataFrame . new ( col1 : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , col2 : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . filter ( df , col2 &gt; 2 ) # Explorer.DataFrame &lt; Polars [ 1 x 2 ] col1 string [ &quot;c&quot; ] col2 integer [ 3 ] &gt; iex&gt; df = Explorer.DataFrame . new ( col1 : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , col2 : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . filter ( df , col1 == &quot;b&quot; ) # Explorer.DataFrame &lt; Polars [ 1 x 2 ] col1 string [ &quot;b&quot; ] col2 integer [ 2 ] &gt; iex&gt; df = Explorer.DataFrame . new ( col1 : [ 5 , 4 , 3 ] , col2 : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . filter ( df , [ col1 &gt; 3 , col2 &lt; 3 ] ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] col1 integer [ 5 , 4 ] col2 integer [ 1 , 2 ] &gt; Returning a non-boolean expression errors: iex&gt; df = Explorer.DataFrame . new ( col1 : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , col2 : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . filter ( df , cumulative_max ( col2 ) ) ** (ArgumentError) expecting the function to return a boolean LazySeries, but instead it returned a LazySeries of type :integer Which can be addressed by converting it to boolean: iex&gt; df = Explorer.DataFrame . new ( col1 : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , col2 : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . filter ( df , cumulative_max ( col2 ) == 1 ) # Explorer.DataFrame &lt; Polars [ 1 x 2 ] col1 string [ &quot;a&quot; ] col2 integer [ 1 ] &gt; Grouped examples In a grouped dataframe, the aggregation is calculated within each group. In the following example we select the flowers of the Iris dataset that have the &quot;petal length&quot; above the average of each species group. iex&gt; df = Explorer.Datasets . iris ( ) iex&gt; grouped = Explorer.DataFrame . group_by ( df , &quot;species&quot; ) iex&gt; Explorer.DataFrame . filter ( grouped , petal_length &gt; mean ( petal_length ) ) # Explorer.DataFrame &lt; Polars [ 79 x 5 ] Groups : [ &quot;species&quot; ] sepal_length float [ 4.6 , 5.4 , 5.0 , 4.9 , 5.4 , ... ] sepal_width float [ 3.1 , 3.9 , 3.4 , 3.1 , 3.7 , ... ] petal_length float [ 1.5 , 1.7 , 1.5 , 1.5 , 1.5 , ... ] petal_width float [ 0.2 , 0.4 , 0.2 , 0.1 , 0.2 , ... ] species string [ &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , ... ] &gt;","ref":"Explorer.DataFrame.html#filter/2","title":"Explorer.DataFrame.filter/2","type":"macro"},{"doc":"Picks rows based on a callback function. The callback receives a lazy dataframe. A lazy dataframe does not hold any values, instead it stores all operations in order to execute all filtering performantly. This is a callback version of filter/2 . Examples iex&gt; df = Explorer.DataFrame . new ( col1 : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , col2 : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . filter_with ( df , &amp; Explorer.Series . greater ( &amp;1 [ &quot;col2&quot; ] , 2 ) ) # Explorer.DataFrame &lt; Polars [ 1 x 2 ] col1 string [ &quot;c&quot; ] col2 integer [ 3 ] &gt; iex&gt; df = Explorer.DataFrame . new ( col1 : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , col2 : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . filter_with ( df , fn df -&gt; Explorer.Series . equal ( df [ &quot;col1&quot; ] , &quot;b&quot; ) end ) # Explorer.DataFrame &lt; Polars [ 1 x 2 ] col1 string [ &quot;b&quot; ] col2 integer [ 2 ] &gt; Grouped examples In a grouped dataframe, the aggregation is calculated within each group. In the following example we select the flowers of the Iris dataset that have the &quot;petal length&quot; above the average of each species group. iex&gt; df = Explorer.Datasets . iris ( ) iex&gt; grouped = Explorer.DataFrame . group_by ( df , &quot;species&quot; ) iex&gt; Explorer.DataFrame . filter_with ( grouped , &amp; Explorer.Series . greater ( &amp;1 [ &quot;petal_length&quot; ] , Explorer.Series . mean ( &amp;1 [ &quot;petal_length&quot; ] ) ) ) # Explorer.DataFrame &lt; Polars [ 79 x 5 ] Groups : [ &quot;species&quot; ] sepal_length float [ 4.6 , 5.4 , 5.0 , 4.9 , 5.4 , ... ] sepal_width float [ 3.1 , 3.9 , 3.4 , 3.1 , 3.7 , ... ] petal_length float [ 1.5 , 1.7 , 1.5 , 1.5 , 1.5 , ... ] petal_width float [ 0.2 , 0.4 , 0.2 , 0.1 , 0.2 , ... ] species string [ &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , ... ] &gt;","ref":"Explorer.DataFrame.html#filter_with/2","title":"Explorer.DataFrame.filter_with/2","type":"function"},{"doc":"Reads a delimited file into a dataframe. If the CSV is compressed, it is automatically decompressed. Options :delimiter - A single character used to separate fields within a record. (default: &quot;,&quot; ) :dtypes - A list/map of {&quot;column_name&quot;, dtype} tuples. Any non-specified column has its type imputed from the first 1000 rows. (default: [] ) :header - Does the file have a header of column names as the first row or not? (default: true ) :max_rows - Maximum number of lines to read. (default: nil ) :null_character - The string that should be interpreted as a nil value. (default: &quot;NA&quot; ) :skip_rows - The number of lines to skip at the beginning of the file. (default: 0 ) :columns - A list of column names or indexes to keep. If present, only these columns are read into the dataframe. (default: nil ) :infer_schema_length Maximum number of rows read for schema inference. Setting this to nil will do a full table scan and will be slow (default: 1000 ). :parse_dates - Automatically try to parse dates/ datetimes and time. If parsing fails, columns remain of dtype string :eol_delimiter - A single character used to represent new lines. (default: &quot; &quot; )","ref":"Explorer.DataFrame.html#from_csv/2","title":"Explorer.DataFrame.from_csv/2","type":"function"},{"doc":"Similar to from_csv/2 but raises if there is a problem reading the CSV.","ref":"Explorer.DataFrame.html#from_csv!/2","title":"Explorer.DataFrame.from_csv!/2","type":"function"},{"doc":"Reads an IPC file into a dataframe. Options :columns - List with the name or index of columns to be selected. Defaults to all columns.","ref":"Explorer.DataFrame.html#from_ipc/2","title":"Explorer.DataFrame.from_ipc/2","type":"function"},{"doc":"Similar to from_ipc/2 but raises if there is a problem reading the IPC file.","ref":"Explorer.DataFrame.html#from_ipc!/2","title":"Explorer.DataFrame.from_ipc!/2","type":"function"},{"doc":"Reads an IPC Streaming file into a dataframe. It's possible to read from an IPC Streaming file using the lazy Polars backend, but the implementation is not truly lazy. We are going to read it first using the eager backend, and then convert the dataframe to lazy. Options :columns - List with the name or index of columns to be selected. Defaults to all columns.","ref":"Explorer.DataFrame.html#from_ipc_stream/2","title":"Explorer.DataFrame.from_ipc_stream/2","type":"function"},{"doc":"Similar to from_ipc_stream/2 but raises if there is a problem reading the IPC Stream file.","ref":"Explorer.DataFrame.html#from_ipc_stream!/2","title":"Explorer.DataFrame.from_ipc_stream!/2","type":"function"},{"doc":"Read a file of JSON objects or lists separated by new lines Options :batch_size - Sets the batch size for reading rows. This value may have significant impact in performance, so adjust it for your needs (default: 1000 ). :infer_schema_length - Maximum number of rows read for schema inference. Setting this to nil will do a full table scan and will be slow (default: 1000 ).","ref":"Explorer.DataFrame.html#from_ndjson/2","title":"Explorer.DataFrame.from_ndjson/2","type":"function"},{"doc":"Similar to from_ndjson/2 , but raises in case of error.","ref":"Explorer.DataFrame.html#from_ndjson!/2","title":"Explorer.DataFrame.from_ndjson!/2","type":"function"},{"doc":"Reads a parquet file into a dataframe. Options :max_rows - Maximum number of lines to read. (default: nil ) :columns - A list of column names or indexes to keep. If present, only these columns are read into the dataframe. (default: nil )","ref":"Explorer.DataFrame.html#from_parquet/2","title":"Explorer.DataFrame.from_parquet/2","type":"function"},{"doc":"Similar to from_parquet/2 but raises if there is a problem reading the Parquet file.","ref":"Explorer.DataFrame.html#from_parquet!/2","title":"Explorer.DataFrame.from_parquet!/2","type":"function"},{"doc":"Group the dataframe by one or more variables. When the dataframe has grouping variables, operations are performed per group. Explorer.DataFrame.ungroup/2 removes grouping. Examples You can group by a single variable: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . group_by ( df , &quot;country&quot; ) # Explorer.DataFrame &lt; Polars [ 1094 x 10 ] Groups : [ &quot;country&quot; ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , ... ] total integer [ 2308 , 1254 , 32500 , 141 , 7924 , ... ] solid_fuel integer [ 627 , 117 , 332 , 0 , 0 , ... ] liquid_fuel integer [ 1601 , 953 , 12381 , 141 , 3649 , ... ] gas_fuel integer [ 74 , 7 , 14565 , 0 , 374 , ... ] cement integer [ 5 , 177 , 2598 , 0 , 204 , ... ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 , ... ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , ... ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 , ... ] &gt; Or you can group by multiple columns in a given list: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . group_by ( df , [ &quot;country&quot; , &quot;year&quot; ] ) # Explorer.DataFrame &lt; Polars [ 1094 x 10 ] Groups : [ &quot;country&quot; , &quot;year&quot; ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , ... ] total integer [ 2308 , 1254 , 32500 , 141 , 7924 , ... ] solid_fuel integer [ 627 , 117 , 332 , 0 , 0 , ... ] liquid_fuel integer [ 1601 , 953 , 12381 , 141 , 3649 , ... ] gas_fuel integer [ 74 , 7 , 14565 , 0 , 374 , ... ] cement integer [ 5 , 177 , 2598 , 0 , 204 , ... ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 , ... ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , ... ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 , ... ] &gt; Or by a range: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . group_by ( df , 0 .. 1 ) # Explorer.DataFrame &lt; Polars [ 1094 x 10 ] Groups : [ &quot;year&quot; , &quot;country&quot; ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , ... ] total integer [ 2308 , 1254 , 32500 , 141 , 7924 , ... ] solid_fuel integer [ 627 , 117 , 332 , 0 , 0 , ... ] liquid_fuel integer [ 1601 , 953 , 12381 , 141 , 3649 , ... ] gas_fuel integer [ 74 , 7 , 14565 , 0 , 374 , ... ] cement integer [ 5 , 177 , 2598 , 0 , 204 , ... ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 , ... ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , ... ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 , ... ] &gt; Regexes and functions are also accepted in column names, as in select/2 .","ref":"Explorer.DataFrame.html#group_by/2","title":"Explorer.DataFrame.group_by/2","type":"function"},{"doc":"Returns the groups of a dataframe. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; df = Explorer.DataFrame . group_by ( df , &quot;country&quot; ) iex&gt; Explorer.DataFrame . groups ( df ) [ &quot;country&quot; ] iex&gt; df = Explorer.Datasets . iris ( ) iex&gt; Explorer.DataFrame . groups ( df ) [ ]","ref":"Explorer.DataFrame.html#groups/1","title":"Explorer.DataFrame.groups/1","type":"function"},{"doc":"Returns the first n rows of the dataframe. By default it returns the first 5 rows. If the dataframe is using groups, then the first n rows of each group is returned. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . head ( df ) # Explorer.DataFrame &lt; Polars [ 5 x 10 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; ] total integer [ 2308 , 1254 , 32500 , 141 , 7924 ] solid_fuel integer [ 627 , 117 , 332 , 0 , 0 ] liquid_fuel integer [ 1601 , 953 , 12381 , 141 , 3649 ] gas_fuel integer [ 74 , 7 , 14565 , 0 , 374 ] cement integer [ 5 , 177 , 2598 , 0 , 204 ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 ] &gt; iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . head ( df , 2 ) # Explorer.DataFrame &lt; Polars [ 2 x 10 ] year integer [ 2010 , 2010 ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; ] total integer [ 2308 , 1254 ] solid_fuel integer [ 627 , 117 ] liquid_fuel integer [ 1601 , 953 ] gas_fuel integer [ 74 , 7 ] cement integer [ 5 , 177 ] gas_flaring integer [ 0 , 0 ] per_capita float [ 0.08 , 0.43 ] bunker_fuels integer [ 9 , 7 ] &gt; Grouped examples Using grouped dataframes makes head/2 return n rows from each group. Here is an example using the Iris dataset, and returning two rows from each group: iex&gt; df = Explorer.Datasets . iris ( ) iex&gt; grouped = Explorer.DataFrame . group_by ( df , &quot;species&quot; ) iex&gt; Explorer.DataFrame . head ( grouped , 2 ) # Explorer.DataFrame &lt; Polars [ 6 x 5 ] Groups : [ &quot;species&quot; ] sepal_length float [ 5.1 , 4.9 , 7.0 , 6.4 , 6.3 , ... ] sepal_width float [ 3.5 , 3.0 , 3.2 , 3.2 , 3.3 , ... ] petal_length float [ 1.4 , 1.4 , 4.7 , 4.5 , 6.0 , ... ] petal_width float [ 0.2 , 0.2 , 1.4 , 1.5 , 2.5 , ... ] species string [ &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-versicolor&quot; , &quot;Iris-versicolor&quot; , &quot;Iris-virginica&quot; , ... ] &gt;","ref":"Explorer.DataFrame.html#head/2","title":"Explorer.DataFrame.head/2","type":"function"},{"doc":"Join two tables. Join types :inner - Returns all rows from left where there are matching values in right , and all columns from left and right . :left - Returns all rows from left and all columns from left and right . Rows in left with no match in right will have nil values in the new columns. :right - Returns all rows from right and all columns from left and right . Rows in right with no match in left will have nil values in the new columns. :outer - Returns all rows and all columns from both left and right . Where there are not matching values, returns nil for the one missing. :cross - Also known as a cartesian join. Returns all combinations of left and right . Can be very computationally expensive. Options :on - The columns to join on. Defaults to overlapping columns. Does not apply to cross join. :how - One of the join types (as an atom) described above. Defaults to :inner . Examples Inner join: iex&gt; left = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; right = Explorer.DataFrame . new ( a : [ 1 , 2 , 2 ] , c : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] ) iex&gt; Explorer.DataFrame . join ( left , right ) # Explorer.DataFrame &lt; Polars [ 3 x 3 ] a integer [ 1 , 2 , 2 ] b string [ &quot;a&quot; , &quot;b&quot; , &quot;b&quot; ] c string [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] &gt; Left join: iex&gt; left = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; right = Explorer.DataFrame . new ( a : [ 1 , 2 , 2 ] , c : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] ) iex&gt; Explorer.DataFrame . join ( left , right , how : :left ) # Explorer.DataFrame &lt; Polars [ 4 x 3 ] a integer [ 1 , 2 , 2 , 3 ] b string [ &quot;a&quot; , &quot;b&quot; , &quot;b&quot; , &quot;c&quot; ] c string [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; , nil ] &gt; Right join: iex&gt; left = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; right = Explorer.DataFrame . new ( a : [ 1 , 2 , 4 ] , c : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] ) iex&gt; Explorer.DataFrame . join ( left , right , how : :right ) # Explorer.DataFrame &lt; Polars [ 3 x 3 ] a integer [ 1 , 2 , 4 ] c string [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] b string [ &quot;a&quot; , &quot;b&quot; , nil ] &gt; Outer join: iex&gt; left = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; right = Explorer.DataFrame . new ( a : [ 1 , 2 , 4 ] , c : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] ) iex&gt; Explorer.DataFrame . join ( left , right , how : :outer ) # Explorer.DataFrame &lt; Polars [ 4 x 3 ] a integer [ 1 , 2 , 4 , 3 ] b string [ &quot;a&quot; , &quot;b&quot; , nil , &quot;c&quot; ] c string [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; , nil ] &gt; Cross join: iex&gt; left = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; right = Explorer.DataFrame . new ( a : [ 1 , 2 , 4 ] , c : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] ) iex&gt; Explorer.DataFrame . join ( left , right , how : :cross ) # Explorer.DataFrame &lt; Polars [ 9 x 4 ] a integer [ 1 , 1 , 1 , 2 , 2 , ... ] b string [ &quot;a&quot; , &quot;a&quot; , &quot;a&quot; , &quot;b&quot; , &quot;b&quot; , ... ] a_right integer [ 1 , 2 , 4 , 1 , 2 , ... ] c string [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; , &quot;d&quot; , &quot;e&quot; , ... ] &gt; Inner join with different names: iex&gt; left = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; right = Explorer.DataFrame . new ( d : [ 1 , 2 , 2 ] , c : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] ) iex&gt; Explorer.DataFrame . join ( left , right , on : [ { &quot;a&quot; , &quot;d&quot; } ] ) # Explorer.DataFrame &lt; Polars [ 3 x 3 ] a integer [ 1 , 2 , 2 ] b string [ &quot;a&quot; , &quot;b&quot; , &quot;b&quot; ] c string [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] &gt; Grouped examples When doing a join operation with grouped dataframes, the joined dataframe may keep the groups from only one side. An inner join operation will keep the groups from the left-hand side dataframe: iex&gt; left = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; right = Explorer.DataFrame . new ( a : [ 1 , 2 , 2 ] , c : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] ) iex&gt; grouped_left = Explorer.DataFrame . group_by ( left , &quot;b&quot; ) iex&gt; grouped_right = Explorer.DataFrame . group_by ( right , &quot;c&quot; ) iex&gt; Explorer.DataFrame . join ( grouped_left , grouped_right ) # Explorer.DataFrame &lt; Polars [ 3 x 3 ] Groups : [ &quot;b&quot; ] a integer [ 1 , 2 , 2 ] b string [ &quot;a&quot; , &quot;b&quot; , &quot;b&quot; ] c string [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] &gt; A left join operation will keep the groups from the left-hand side dataframe: iex&gt; left = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; right = Explorer.DataFrame . new ( a : [ 1 , 2 , 2 ] , c : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] ) iex&gt; grouped_left = Explorer.DataFrame . group_by ( left , &quot;b&quot; ) iex&gt; grouped_right = Explorer.DataFrame . group_by ( right , &quot;c&quot; ) iex&gt; Explorer.DataFrame . join ( grouped_left , grouped_right , how : :left ) # Explorer.DataFrame &lt; Polars [ 4 x 3 ] Groups : [ &quot;b&quot; ] a integer [ 1 , 2 , 2 , 3 ] b string [ &quot;a&quot; , &quot;b&quot; , &quot;b&quot; , &quot;c&quot; ] c string [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; , nil ] &gt; A right join operation will keep the groups from the right-hand side dataframe: iex&gt; left = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; right = Explorer.DataFrame . new ( a : [ 1 , 2 , 4 ] , c : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] ) iex&gt; grouped_left = Explorer.DataFrame . group_by ( left , &quot;b&quot; ) iex&gt; grouped_right = Explorer.DataFrame . group_by ( right , &quot;c&quot; ) iex&gt; Explorer.DataFrame . join ( grouped_left , grouped_right , how : :right ) # Explorer.DataFrame &lt; Polars [ 3 x 3 ] Groups : [ &quot;c&quot; ] a integer [ 1 , 2 , 4 ] c string [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] b string [ &quot;a&quot; , &quot;b&quot; , nil ] &gt; An outer join operation is going to keep the groups from the left-hand side dataframe: iex&gt; left = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; right = Explorer.DataFrame . new ( a : [ 1 , 2 , 4 ] , c : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] ) iex&gt; grouped_left = Explorer.DataFrame . group_by ( left , &quot;b&quot; ) iex&gt; grouped_right = Explorer.DataFrame . group_by ( right , &quot;c&quot; ) iex&gt; Explorer.DataFrame . join ( grouped_left , grouped_right , how : :outer ) # Explorer.DataFrame &lt; Polars [ 4 x 3 ] Groups : [ &quot;b&quot; ] a integer [ 1 , 2 , 4 , 3 ] b string [ &quot;a&quot; , &quot;b&quot; , nil , &quot;c&quot; ] c string [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; , nil ] &gt; A cross join operation is going to keep the groups from the left-hand side dataframe: iex&gt; left = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; right = Explorer.DataFrame . new ( a : [ 1 , 2 , 4 ] , c : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] ) iex&gt; grouped_left = Explorer.DataFrame . group_by ( left , &quot;b&quot; ) iex&gt; grouped_right = Explorer.DataFrame . group_by ( right , &quot;c&quot; ) iex&gt; Explorer.DataFrame . join ( grouped_left , grouped_right , how : :cross ) # Explorer.DataFrame &lt; Polars [ 9 x 4 ] Groups : [ &quot;b&quot; ] a integer [ 1 , 1 , 1 , 2 , 2 , ... ] b string [ &quot;a&quot; , &quot;a&quot; , &quot;a&quot; , &quot;b&quot; , &quot;b&quot; , ... ] a_right integer [ 1 , 2 , 4 , 1 , 2 , ... ] c string [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; , &quot;d&quot; , &quot;e&quot; , ... ] &gt;","ref":"Explorer.DataFrame.html#join/3","title":"Explorer.DataFrame.join/3","type":"function"},{"doc":"Reads a representation of a CSV file into a dataframe. If the CSV is compressed, it is automatically decompressed. Options :delimiter - A single character used to separate fields within a record. (default: &quot;,&quot; ) :dtypes - A list/map of {&quot;column_name&quot;, dtype} tuples. Any non-specified column has its type imputed from the first 1000 rows. (default: [] ) :header - Does the file have a header of column names as the first row or not? (default: true ) :max_rows - Maximum number of lines to read. (default: nil ) :null_character - The string that should be interpreted as a nil value. (default: &quot;NA&quot; ) :skip_rows - The number of lines to skip at the beginning of the file. (default: 0 ) :columns - A list of column names or indexes to keep. If present, only these columns are read into the dataframe. (default: nil ) :infer_schema_length Maximum number of rows read for schema inference. Setting this to nil will do a full table scan and will be slow (default: 1000 ). :parse_dates - Automatically try to parse dates/ datetimes and time. If parsing fails, columns remain of dtype string :eol_delimiter - A single character used to represent new lines. (default: &quot; &quot; )","ref":"Explorer.DataFrame.html#load_csv/2","title":"Explorer.DataFrame.load_csv/2","type":"function"},{"doc":"Similar to load_csv/2 but raises if there is a problem reading the CSV.","ref":"Explorer.DataFrame.html#load_csv!/2","title":"Explorer.DataFrame.load_csv!/2","type":"function"},{"doc":"Reads a binary representing an IPC file into a dataframe. Options :columns - List with the name or index of columns to be selected. Defaults to all columns.","ref":"Explorer.DataFrame.html#load_ipc/2","title":"Explorer.DataFrame.load_ipc/2","type":"function"},{"doc":"Similar to load_ipc/2 but raises if there is a problem reading the IPC file.","ref":"Explorer.DataFrame.html#load_ipc!/2","title":"Explorer.DataFrame.load_ipc!/2","type":"function"},{"doc":"Reads a binary representing an IPC Stream file into a dataframe. Options :columns - List with the name or index of columns to be selected. Defaults to all columns.","ref":"Explorer.DataFrame.html#load_ipc_stream/2","title":"Explorer.DataFrame.load_ipc_stream/2","type":"function"},{"doc":"Similar to load_ipc_stream/2 but raises if there is a problem.","ref":"Explorer.DataFrame.html#load_ipc_stream!/2","title":"Explorer.DataFrame.load_ipc_stream!/2","type":"function"},{"doc":"Reads a representation of a NDJSON file into a dataframe. Options :batch_size - Sets the batch size for reading rows. This value may have significant impact in performance, so adjust it for your needs (default: 1000 ). :infer_schema_length - Maximum number of rows read for schema inference. Setting this to nil will do a full table scan and will be slow (default: 1000 ).","ref":"Explorer.DataFrame.html#load_ndjson/2","title":"Explorer.DataFrame.load_ndjson/2","type":"function"},{"doc":"Similar to load_ndjson/2 , but raises in case of error. Examples iex&gt; contents = ~s({&quot;col_a&quot;:1,&quot;col_b&quot;:5.1} \\n {&quot;col_a&quot;:2,&quot;col_b&quot;:5.2} \\n ) iex&gt; Explorer.DataFrame . load_ndjson! ( contents ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] col_a integer [ 1 , 2 ] col_b float [ 5.1 , 5.2 ] &gt;","ref":"Explorer.DataFrame.html#load_ndjson!/2","title":"Explorer.DataFrame.load_ndjson!/2","type":"function"},{"doc":"Reads a binary representation of a parquet file into a dataframe.","ref":"Explorer.DataFrame.html#load_parquet/2","title":"Explorer.DataFrame.load_parquet/2","type":"function"},{"doc":"Similar to load_parquet/2 but raises if there is a problem reading the Parquet file.","ref":"Explorer.DataFrame.html#load_parquet!/2","title":"Explorer.DataFrame.load_parquet!/2","type":"function"},{"doc":"Picks rows based on a list or series of values. Examples This function must only be used when you need to select rows based on external values that are not available to the dataframe. For example, you can pass a list: iex&gt; df = Explorer.DataFrame . new ( col1 : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , col2 : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . mask ( df , [ false , true , false ] ) # Explorer.DataFrame &lt; Polars [ 1 x 2 ] col1 string [ &quot;b&quot; ] col2 integer [ 2 ] &gt; You must avoid using masks when the masks themselves are computed from other columns. For example, DO NOT do this: iex&gt; df = Explorer.DataFrame . new ( col1 : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , col2 : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . mask ( df , Explorer.Series . greater ( df [ &quot;col2&quot; ] , 1 ) ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] col1 string [ &quot;b&quot; , &quot;c&quot; ] col2 integer [ 2 , 3 ] &gt; Instead, do this: iex&gt; df = Explorer.DataFrame . new ( col1 : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , col2 : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . filter_with ( df , fn df -&gt; Explorer.Series . greater ( df [ &quot;col2&quot; ] , 1 ) end ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] col1 string [ &quot;b&quot; , &quot;c&quot; ] col2 integer [ 2 , 3 ] &gt; The filter_with/2 version is much more efficient because it doesn't need to create intermediate series representations to apply the mask.","ref":"Explorer.DataFrame.html#mask/2","title":"Explorer.DataFrame.mask/2","type":"function"},{"doc":"Creates or modifies columns based on Explorer.Query . The query is compiled and runs efficiently against the dataframe. New variables overwrite existing variables of the same name. Column names are coerced from atoms to strings. Notice This is a macro. You must require Explorer.DataFrame before using it. Besides element-wise series operations, you can also use window functions and aggregations inside mutations. In such cases, grouped dataframes may have different results than ungrouped ones, because the mutation is computed withing groups. See examples below. See mutate_with/2 for a callback version of this function without Explorer.Query . If your mutation cannot be expressed with queries, you may compute the values using the Explorer.Series API directly and then add it to the dataframe using put/3 . Examples Mutations are useful to add or modify columns in your dataframe: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . mutate ( df , c : b + 1 ) # Explorer.DataFrame &lt; Polars [ 3 x 3 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] b integer [ 1 , 2 , 3 ] c integer [ 2 , 3 , 4 ] &gt; It's also possible to overwrite existing columns: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . mutate ( df , a : b * 2 ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] a integer [ 2 , 4 , 6 ] b integer [ 1 , 2 , 3 ] &gt; Scalar values are repeated to fill the series: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . mutate ( df , a : 4 ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] a integer [ 4 , 4 , 4 ] b integer [ 1 , 2 , 3 ] &gt; It's also possible to use functions from the Series module, like Explorer.Series.window_sum/3 : iex&gt; df = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . mutate ( df , b : window_sum ( a , 2 ) ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] a integer [ 1 , 2 , 3 ] b integer [ 1 , 3 , 5 ] &gt; Alternatively, all of the above works with a map instead of a keyword list: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . mutate ( df , %{ &quot;c&quot; =&gt; cast ( b , :float ) } ) # Explorer.DataFrame &lt; Polars [ 3 x 3 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] b integer [ 1 , 2 , 3 ] c float [ 1.0 , 2.0 , 3.0 ] &gt; Grouped examples Mutations in grouped dataframes takes the context of the group. This enables some aggregations to be made considering each group. It's almost like summarise/2 , but repeating the results for each member in the group. For example, if we want to count how many elements of a given group, we can add a new column with that aggregation: iex&gt; df = Explorer.DataFrame . new ( id : [ &quot;a&quot; , &quot;a&quot; , &quot;b&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; grouped = Explorer.DataFrame . group_by ( df , :id ) iex&gt; Explorer.DataFrame . mutate ( grouped , count : count ( b ) ) # Explorer.DataFrame &lt; Polars [ 3 x 3 ] Groups : [ &quot;id&quot; ] id string [ &quot;a&quot; , &quot;a&quot; , &quot;b&quot; ] b integer [ 1 , 2 , 3 ] count integer [ 2 , 2 , 1 ] &gt; In case we want to get the average size of the petal length from the Iris dataset, we can: iex&gt; df = Explorer.Datasets . iris ( ) iex&gt; grouped = Explorer.DataFrame . group_by ( df , &quot;species&quot; ) iex&gt; Explorer.DataFrame . mutate ( grouped , petal_length_avg : mean ( petal_length ) ) # Explorer.DataFrame &lt; Polars [ 150 x 6 ] Groups : [ &quot;species&quot; ] sepal_length float [ 5.1 , 4.9 , 4.7 , 4.6 , 5.0 , ... ] sepal_width float [ 3.5 , 3.0 , 3.2 , 3.1 , 3.6 , ... ] petal_length float [ 1.4 , 1.4 , 1.3 , 1.5 , 1.4 , ... ] petal_width float [ 0.2 , 0.2 , 0.2 , 0.2 , 0.2 , ... ] species string [ &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , ... ] petal_length_avg float [ 1.4640000000000004 , 1.4640000000000004 , 1.4640000000000004 , 1.4640000000000004 , 1.4640000000000004 , ... ] &gt;","ref":"Explorer.DataFrame.html#mutate/2","title":"Explorer.DataFrame.mutate/2","type":"macro"},{"doc":"Creates or modifies columns using a callback function. The callback receives a lazy dataframe. A lazy dataframe does hold any values, instead it stores all operations in order to execute all mutations performantly. This is a callback version of mutate/2 . If your mutation cannot be expressed with lazy dataframes, you may compute the values using the Explorer.Series API directly and then add it to the dataframe using put/3 . Examples Here is an example of a new column that sums the value of two other columns: iex&gt; df = Explorer.DataFrame . new ( a : [ 4 , 5 , 6 ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . mutate_with ( df , &amp; [ c : Explorer.Series . add ( &amp;1 [ &quot;a&quot; ] , &amp;1 [ &quot;b&quot; ] ) ] ) # Explorer.DataFrame &lt; Polars [ 3 x 3 ] a integer [ 4 , 5 , 6 ] b integer [ 1 , 2 , 3 ] c integer [ 5 , 7 , 9 ] &gt; You can overwrite existing columns as well: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . mutate_with ( df , &amp; [ b : Explorer.Series . pow ( &amp;1 [ &quot;b&quot; ] , 2 ) ] ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] b float [ 1.0 , 4.0 , 9.0 ] &gt; It's possible to &quot;reuse&quot; a variable for different computations: iex&gt; df = Explorer.DataFrame . new ( a : [ 4 , 5 , 6 ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . mutate_with ( df , fn ldf -&gt; iex&gt; c = Explorer.Series . add ( ldf [ &quot;a&quot; ] , ldf [ &quot;b&quot; ] ) iex&gt; [ c : c , d : Explorer.Series . window_sum ( c , 2 ) ] iex&gt; end ) # Explorer.DataFrame &lt; Polars [ 3 x 4 ] a integer [ 4 , 5 , 6 ] b integer [ 1 , 2 , 3 ] c integer [ 5 , 7 , 9 ] d integer [ 5 , 12 , 16 ] &gt; Grouped examples Mutations in grouped dataframes takes the context of the group. For example, if we want to count how many elements of a given group, we can add a new column with that aggregation: iex&gt; df = Explorer.DataFrame . new ( id : [ &quot;a&quot; , &quot;a&quot; , &quot;b&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; grouped = Explorer.DataFrame . group_by ( df , :id ) iex&gt; Explorer.DataFrame . mutate_with ( grouped , &amp; [ count : Explorer.Series . count ( &amp;1 [ &quot;b&quot; ] ) ] ) # Explorer.DataFrame &lt; Polars [ 3 x 3 ] Groups : [ &quot;id&quot; ] id string [ &quot;a&quot; , &quot;a&quot; , &quot;b&quot; ] b integer [ 1 , 2 , 3 ] count integer [ 2 , 2 , 1 ] &gt;","ref":"Explorer.DataFrame.html#mutate_with/2","title":"Explorer.DataFrame.mutate_with/2","type":"function"},{"doc":"Returns the number of columns in the dataframe. This function works the same way for grouped dataframes. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . n_columns ( df ) 10","ref":"Explorer.DataFrame.html#n_columns/1","title":"Explorer.DataFrame.n_columns/1","type":"function"},{"doc":"Returns the number of rows in the dataframe. This function works the same way for grouped dataframes, considering the entire dataframe in the counting of rows. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . n_rows ( df ) 1094","ref":"Explorer.DataFrame.html#n_rows/1","title":"Explorer.DataFrame.n_rows/1","type":"function"},{"doc":"Gets the names of the dataframe columns. Examples iex&gt; df = Explorer.DataFrame . new ( floats : [ 1.0 , 2.0 ] , ints : [ 1 , 2 ] ) iex&gt; Explorer.DataFrame . names ( df ) [ &quot;floats&quot; , &quot;ints&quot; ]","ref":"Explorer.DataFrame.html#names/1","title":"Explorer.DataFrame.names/1","type":"function"},{"doc":"Creates a new dataframe. It accepts any of: a map or keyword list of string/atom keys and series as values a map or keyword list of string/atom keys and tensors as values any data structure adhering to the Table.Reader protocol Options :backend - The Explorer backend to use. Defaults to the value returned by Explorer.Backend.get/0 . :dtypes - A list/map of {column_name, dtype} pairs. (default: [] ) Examples From series Series can be given either as keyword lists or maps where the keys are the name and the values are series: iex&gt; Explorer.DataFrame . new ( %{ ...&gt; floats : Explorer.Series . from_list ( [ 1.0 , 2.0 ] ) , ...&gt; ints : Explorer.Series . from_list ( [ 1 , nil ] ) ...&gt; } ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] floats float [ 1.0 , 2.0 ] ints integer [ 1 , nil ] &gt; From tensors To create dataframe from tensors, you can pass a matrix as argument. Each matrix column becomes a dataframe column with names x1, x2, x3, etc: iex&gt; Explorer.DataFrame . new ( Nx . tensor ( [ ...&gt; [ 1 , 2 , 3 ] , ...&gt; [ 4 , 5 , 6 ] ...&gt; ] ) ) # Explorer.DataFrame &lt; Polars [ 2 x 3 ] x1 integer [ 1 , 4 ] x2 integer [ 2 , 5 ] x3 integer [ 3 , 6 ] &gt; Explorer expects tensors to have certain types, so you may need to cast the data accordingly. See Explorer.Series.from_tensor/2 for more info. You can also pass a keyword list or maps of vectors (rank 1 tensors): iex&gt; Explorer.DataFrame . new ( %{ ...&gt; floats : Nx . tensor ( [ 1.0 , 2.0 ] , type : :f64 ) , ...&gt; ints : Nx . tensor ( [ 3 , 4 ] ) ...&gt; } ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] floats float [ 1.0 , 2.0 ] ints integer [ 3 , 4 ] &gt; Use dtypes to force a particular representation: iex&gt; Explorer.DataFrame . new ( %{ ...&gt; floats : Nx . tensor ( [ 1.0 , 2.0 ] , type : :f64 ) , ...&gt; times : Nx . tensor ( [ 3 , 4 ] ) ...&gt; } , dtypes : [ times : :time ] ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] floats float [ 1.0 , 2.0 ] times time [ 00 : 00 : 00.000003 , 00 : 00 : 00.000004 ] &gt; From tabular Tabular data can be either columnar or row-based. Let's start with column data: iex&gt; Explorer.DataFrame . new ( %{ floats : [ 1.0 , 2.0 ] , ints : [ 1 , nil ] } ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] floats float [ 1.0 , 2.0 ] ints integer [ 1 , nil ] &gt; iex&gt; Explorer.DataFrame . new ( floats : [ 1.0 , 2.0 ] , ints : [ 1 , nil ] ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] floats float [ 1.0 , 2.0 ] ints integer [ 1 , nil ] &gt; iex&gt; Explorer.DataFrame . new ( %{ floats : [ 1.0 , 2.0 ] , ints : [ 1 , nil ] , binaries : [ &lt;&lt; 239 , 191 , 19 &gt;&gt; , nil ] } , dtypes : [ { :binaries , :binary } ] ) # Explorer.DataFrame &lt; Polars [ 2 x 3 ] binaries binary [ &lt;&lt; 239 , 191 , 19 &gt;&gt; , nil ] floats float [ 1.0 , 2.0 ] ints integer [ 1 , nil ] &gt; iex&gt; Explorer.DataFrame . new ( %{ floats : [ 1.0 , 2.0 ] , ints : [ 1 , &quot;wrong&quot; ] } ) ** (ArgumentError) cannot create series &quot;ints&quot;: the value &quot;wrong&quot; does not match the inferred series dtype :integer From row data: iex&gt; rows = [ %{ id : 1 , name : &quot;José&quot; } , %{ id : 2 , name : &quot;Christopher&quot; } , %{ id : 3 , name : &quot;Cristine&quot; } ] iex&gt; Explorer.DataFrame . new ( rows ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] id integer [ 1 , 2 , 3 ] name string [ &quot;José&quot; , &quot;Christopher&quot; , &quot;Cristine&quot; ] &gt; iex&gt; rows = [ [ id : 1 , name : &quot;José&quot; ] , [ id : 2 , name : &quot;Christopher&quot; ] , [ id : 3 , name : &quot;Cristine&quot; ] ] iex&gt; Explorer.DataFrame . new ( rows ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] id integer [ 1 , 2 , 3 ] name string [ &quot;José&quot; , &quot;Christopher&quot; , &quot;Cristine&quot; ] &gt;","ref":"Explorer.DataFrame.html#new/2","title":"Explorer.DataFrame.new/2","type":"function"},{"doc":"Pivot data from wide to long. pivot_longer/3 &quot;lengthens&quot; data, increasing the number of rows and decreasing the number of columns. The inverse transformation is pivot_wider/4 . The second argument, columns_to_pivot , can be either list of column names to pivot. Ranges, regexes, and functions are also accepted in column names, as in select/2 . The selected columns must always have the same data type. In case the dataframe is using groups, the groups that are also in the list of columns to pivot will be removed from the resultant dataframe. See the examples below. Options :select - Columns that are not in the list of pivot and should be kept in the dataframe. Ranges, regexes, and functions are also accepted in column names, as in select/2 . Defaults to all columns except the ones to pivot. :discard - Columns that are not in the list of pivot and should be dropped from the dataframe. Ranges, regexes, and functions are also accepted in column names, as in select/2 . This list of columns is going to be subtracted from the list of select . Defaults to an empty list. :names_to - A string specifying the name of the column to create from the data stored in the column names of the dataframe. Defaults to &quot;variable&quot; . :values_to - A string specifying the name of the column to create from the data stored in series element values. Defaults to &quot;value&quot; . Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . pivot_longer ( df , &amp; String . ends_with? ( &amp;1 , &quot;fuel&quot; ) ) # Explorer.DataFrame &lt; Polars [ 3282 x 9 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , ... ] total integer [ 2308 , 1254 , 32500 , 141 , 7924 , ... ] cement integer [ 5 , 177 , 2598 , 0 , 204 , ... ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 , ... ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , ... ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 , ... ] variable string [ &quot;solid_fuel&quot; , &quot;solid_fuel&quot; , &quot;solid_fuel&quot; , &quot;solid_fuel&quot; , &quot;solid_fuel&quot; , ... ] value integer [ 627 , 117 , 332 , 0 , 0 , ... ] &gt; iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . pivot_longer ( df , &amp; String . ends_with? ( &amp;1 , &quot;fuel&quot; ) , select : [ &quot;year&quot; , &quot;country&quot; ] ) # Explorer.DataFrame &lt; Polars [ 3282 x 4 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , ... ] variable string [ &quot;solid_fuel&quot; , &quot;solid_fuel&quot; , &quot;solid_fuel&quot; , &quot;solid_fuel&quot; , &quot;solid_fuel&quot; , ... ] value integer [ 627 , 117 , 332 , 0 , 0 , ... ] &gt; iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . pivot_longer ( df , [ &quot;total&quot; ] , select : [ &quot;year&quot; , &quot;country&quot; ] , discard : [ &quot;country&quot; ] ) # Explorer.DataFrame &lt; Polars [ 1094 x 3 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] variable string [ &quot;total&quot; , &quot;total&quot; , &quot;total&quot; , &quot;total&quot; , &quot;total&quot; , ... ] value integer [ 2308 , 1254 , 32500 , 141 , 7924 , ... ] &gt; iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . pivot_longer ( df , [ &quot;total&quot; ] , select : [ ] , names_to : &quot;my_var&quot; , values_to : &quot;my_value&quot; ) # Explorer.DataFrame &lt; Polars [ 1094 x 2 ] my_var string [ &quot;total&quot; , &quot;total&quot; , &quot;total&quot; , &quot;total&quot; , &quot;total&quot; , ... ] my_value integer [ 2308 , 1254 , 32500 , 141 , 7924 , ... ] &gt; Grouped examples In the following example we want to take the Iris dataset and increase the number of rows by pivoting the &quot;sepal_length&quot; column. This dataset is grouped by &quot;species&quot;, so the resultant dataframe is going to keep the &quot;species&quot; group: iex&gt; df = Explorer.Datasets . iris ( ) iex&gt; grouped = Explorer.DataFrame . group_by ( df , &quot;species&quot; ) iex&gt; Explorer.DataFrame . pivot_longer ( grouped , [ &quot;sepal_length&quot; ] ) # Explorer.DataFrame &lt; Polars [ 150 x 6 ] Groups : [ &quot;species&quot; ] sepal_width float [ 3.5 , 3.0 , 3.2 , 3.1 , 3.6 , ... ] petal_length float [ 1.4 , 1.4 , 1.3 , 1.5 , 1.4 , ... ] petal_width float [ 0.2 , 0.2 , 0.2 , 0.2 , 0.2 , ... ] species string [ &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , ... ] variable string [ &quot;sepal_length&quot; , &quot;sepal_length&quot; , &quot;sepal_length&quot; , &quot;sepal_length&quot; , &quot;sepal_length&quot; , ... ] value float [ 5.1 , 4.9 , 4.7 , 4.6 , 5.0 , ... ] &gt; Now we want to do something different: we want to pivot the &quot;species&quot; column that is also a group. This is going to remove the group in the resultant dataframe: iex&gt; df = Explorer.Datasets . iris ( ) iex&gt; grouped = Explorer.DataFrame . group_by ( df , &quot;species&quot; ) iex&gt; Explorer.DataFrame . pivot_longer ( grouped , [ &quot;species&quot; ] ) # Explorer.DataFrame &lt; Polars [ 150 x 6 ] sepal_length float [ 5.1 , 4.9 , 4.7 , 4.6 , 5.0 , ... ] sepal_width float [ 3.5 , 3.0 , 3.2 , 3.1 , 3.6 , ... ] petal_length float [ 1.4 , 1.4 , 1.3 , 1.5 , 1.4 , ... ] petal_width float [ 0.2 , 0.2 , 0.2 , 0.2 , 0.2 , ... ] variable string [ &quot;species&quot; , &quot;species&quot; , &quot;species&quot; , &quot;species&quot; , &quot;species&quot; , ... ] value string [ &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , ... ] &gt;","ref":"Explorer.DataFrame.html#pivot_longer/3","title":"Explorer.DataFrame.pivot_longer/3","type":"function"},{"doc":"Pivot data from long to wide. pivot_wider/4 &quot;widens&quot; data, increasing the number of columns and decreasing the number of rows. The inverse transformation is pivot_longer/3 . Due to a restriction upstream, values_from must be a numeric type. In case the dataframe is using groups, the groups that are also in the list of columns to pivot will be removed from the resultant dataframe. See the examples below. Options :id_columns - A set of columns that uniquely identifies each observation. Defaults to all columns in data except for the columns specified in names_from and values_from , and columns that are of the :float dtype. Typically used when you have redundant variables, i.e. variables whose values are perfectly correlated with existing variables. May accept a filter callback, a list or a range of column names. Default value is 0..-1//1 . If an empty list is passed, or a range that results in a empty list of column names, it raises an error. ID columns cannot be of the float type and any columns of this dtype is discarded. If you need to use float columns as IDs, you must carefully consider rounding or truncating the column and converting it to integer, as long as doing so preserves the properties of the column. :names_prefix - String added to the start of every variable name. This is particularly useful if names_from is a numeric vector and you want to create syntactic variable names. Examples Suppose we have a basketball court and multiple teams that want to train in that court. They need to share a schedule with the hours each team is going to use it. Here is a dataframe representing that schedule: iex&gt; Explorer.DataFrame . new ( iex&gt; weekday : [ &quot;Monday&quot; , &quot;Tuesday&quot; , &quot;Wednesday&quot; , &quot;Thursday&quot; , &quot;Friday&quot; , &quot;Monday&quot; , &quot;Tuesday&quot; , &quot;Wednesday&quot; , &quot;Thursday&quot; , &quot;Friday&quot; ] , iex&gt; team : [ &quot;A&quot; , &quot;B&quot; , &quot;C&quot; , &quot;A&quot; , &quot;B&quot; , &quot;C&quot; , &quot;A&quot; , &quot;B&quot; , &quot;C&quot; , &quot;A&quot; ] , iex&gt; hour : [ 10 , 9 , 10 , 10 , 11 , 15 , 14 , 16 , 14 , 16 ] iex&gt; ) This dataframe is going to look like this - using table/2 : + -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- + | Explorer DataFrame : [ rows : 10 , columns : 3 ] | + -- -- -- -- -- -- -- - + -- -- -- -- -- -- -- + -- -- -- -- -- -- -- - + | weekday | team | hour | | &lt; string &gt; | &lt; string &gt; | &lt; integer &gt; | + === === === === === + === === === === == + === === === === === + | Monday | A | 10 | + -- -- -- -- -- -- -- - + -- -- -- -- -- -- -- + -- -- -- -- -- -- -- - + | Tuesday | B | 9 | + -- -- -- -- -- -- -- - + -- -- -- -- -- -- -- + -- -- -- -- -- -- -- - + | Wednesday | C | 10 | + -- -- -- -- -- -- -- - + -- -- -- -- -- -- -- + -- -- -- -- -- -- -- - + | Thursday | A | 10 | + -- -- -- -- -- -- -- - + -- -- -- -- -- -- -- + -- -- -- -- -- -- -- - + | Friday | B | 11 | + -- -- -- -- -- -- -- - + -- -- -- -- -- -- -- + -- -- -- -- -- -- -- - + | Monday | C | 15 | + -- -- -- -- -- -- -- - + -- -- -- -- -- -- -- + -- -- -- -- -- -- -- - + | Tuesday | A | 14 | + -- -- -- -- -- -- -- - + -- -- -- -- -- -- -- + -- -- -- -- -- -- -- - + | Wednesday | B | 16 | + -- -- -- -- -- -- -- - + -- -- -- -- -- -- -- + -- -- -- -- -- -- -- - + | Thursday | C | 14 | + -- -- -- -- -- -- -- - + -- -- -- -- -- -- -- + -- -- -- -- -- -- -- - + | Friday | A | 16 | + -- -- -- -- -- -- -- - + -- -- -- -- -- -- -- + -- -- -- -- -- -- -- - + You can see that the &quot;weekday&quot; repeats, and it's not clear how free the agenda is. We can solve that by pivoting the &quot;weekday&quot; column in multiple columns, making each weekday a new column in the resultant dataframe. iex&gt; df = Explorer.DataFrame . new ( iex&gt; weekday : [ &quot;Monday&quot; , &quot;Tuesday&quot; , &quot;Wednesday&quot; , &quot;Thursday&quot; , &quot;Friday&quot; , &quot;Monday&quot; , &quot;Tuesday&quot; , &quot;Wednesday&quot; , &quot;Thursday&quot; , &quot;Friday&quot; ] , iex&gt; team : [ &quot;A&quot; , &quot;B&quot; , &quot;C&quot; , &quot;A&quot; , &quot;B&quot; , &quot;C&quot; , &quot;A&quot; , &quot;B&quot; , &quot;C&quot; , &quot;A&quot; ] , iex&gt; hour : [ 10 , 9 , 10 , 10 , 11 , 15 , 14 , 16 , 14 , 16 ] iex&gt; ) iex&gt; Explorer.DataFrame . pivot_wider ( df , &quot;weekday&quot; , &quot;hour&quot; ) # Explorer.DataFrame &lt; Polars [ 3 x 6 ] team string [ &quot;A&quot; , &quot;B&quot; , &quot;C&quot; ] Monday integer [ 10 , nil , 15 ] Tuesday integer [ 14 , 9 , nil ] Wednesday integer [ nil , 16 , 10 ] Thursday integer [ 10 , nil , 14 ] Friday integer [ 16 , 11 , nil ] &gt; Now if we print that same dataframe with table/2 , we get a better picture of the schedule: + -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- + | Explorer DataFrame : [ rows : 3 , columns : 6 ] | + -- -- -- -- -- + -- -- -- -- -- - + -- -- -- -- -- - + -- -- -- -- -- - + -- -- -- -- -- - + -- -- -- -- -- - + | team | Monday | Tuesday | Wednesday | Thursday | Friday | | &lt; string &gt; | &lt; integer &gt; | &lt; integer &gt; | &lt; integer &gt; | &lt; integer &gt; | &lt; integer &gt; | + === === === = + === === === == + === === === == + === === === == + === === === == + === === === == + | A | 10 | 14 | | 10 | 16 | + -- -- -- -- -- + -- -- -- -- -- - + -- -- -- -- -- - + -- -- -- -- -- - + -- -- -- -- -- - + -- -- -- -- -- - + | B | | 9 | 16 | | 11 | + -- -- -- -- -- + -- -- -- -- -- - + -- -- -- -- -- - + -- -- -- -- -- - + -- -- -- -- -- - + -- -- -- -- -- - + | C | 15 | | 10 | 14 | | + -- -- -- -- -- + -- -- -- -- -- - + -- -- -- -- -- - + -- -- -- -- -- - + -- -- -- -- -- - + -- -- -- -- -- - + Pivot wider can create unpredictable column names, and sometimes they can conflict with ID columns. In that scenario, we add a number as suffix to duplicated column names. Here is an example: iex&gt; df = Explorer.DataFrame . new ( iex&gt; product_id : [ 1 , 1 , 1 , 1 , 2 , 2 , 2 , 2 ] , iex&gt; property : [ &quot;product_id&quot; , &quot;width_cm&quot; , &quot;height_cm&quot; , &quot;length_cm&quot; , &quot;product_id&quot; , &quot;width_cm&quot; , &quot;height_cm&quot; , &quot;length_cm&quot; ] , iex&gt; property_value : [ 1 , 42 , 40 , 64 , 2 , 35 , 20 , 40 ] iex&gt; ) iex&gt; Explorer.DataFrame . pivot_wider ( df , &quot;property&quot; , &quot;property_value&quot; ) # Explorer.DataFrame &lt; Polars [ 2 x 5 ] product_id integer [ 1 , 2 ] product_id_1 integer [ 1 , 2 ] width_cm integer [ 42 , 35 ] height_cm integer [ 40 , 20 ] length_cm integer [ 64 , 40 ] &gt; But if the option :names_prefix is used, that suffix is not added: iex&gt; df = Explorer.DataFrame . new ( iex&gt; product_id : [ 1 , 1 , 1 , 1 , 2 , 2 , 2 , 2 ] , iex&gt; property : [ &quot;product_id&quot; , &quot;width_cm&quot; , &quot;height_cm&quot; , &quot;length_cm&quot; , &quot;product_id&quot; , &quot;width_cm&quot; , &quot;height_cm&quot; , &quot;length_cm&quot; ] , iex&gt; property_value : [ 1 , 42 , 40 , 64 , 2 , 35 , 20 , 40 ] iex&gt; ) iex&gt; Explorer.DataFrame . pivot_wider ( df , &quot;property&quot; , &quot;property_value&quot; , names_prefix : &quot;col_&quot; ) # Explorer.DataFrame &lt; Polars [ 2 x 5 ] product_id integer [ 1 , 2 ] col_product_id integer [ 1 , 2 ] col_width_cm integer [ 42 , 35 ] col_height_cm integer [ 40 , 20 ] col_length_cm integer [ 64 , 40 ] &gt; Multiple columns are accepted for the values_from parameter, but the behaviour is slightly different for the naming of new columns in the resultant dataframe. The new columns are going to be prefixed by the name of the original value column, followed by an underscore and the name of the variable. iex&gt; df = Explorer.DataFrame . new ( iex&gt; product_id : [ 1 , 1 , 1 , 1 , 2 , 2 , 2 , 2 ] , iex&gt; property : [ &quot;product_id&quot; , &quot;width_cm&quot; , &quot;height_cm&quot; , &quot;length_cm&quot; , &quot;product_id&quot; , &quot;width_cm&quot; , &quot;height_cm&quot; , &quot;length_cm&quot; ] , iex&gt; property_value : [ 1 , 42 , 40 , 64 , 2 , 35 , 20 , 40 ] , iex&gt; another_value : [ 1 , 43 , 41 , 65 , 2 , 36 , 21 , 42 ] iex&gt; ) iex&gt; Explorer.DataFrame . pivot_wider ( df , &quot;property&quot; , [ &quot;property_value&quot; , &quot;another_value&quot; ] ) # Explorer.DataFrame &lt; Polars [ 2 x 9 ] product_id integer [ 1 , 2 ] property_value_product_id integer [ 1 , 2 ] property_value_width_cm integer [ 42 , 35 ] property_value_height_cm integer [ 40 , 20 ] property_value_length_cm integer [ 64 , 40 ] another_value_product_id integer [ 1 , 2 ] another_value_width_cm integer [ 43 , 36 ] another_value_height_cm integer [ 41 , 21 ] another_value_length_cm integer [ 65 , 42 ] &gt; Grouped examples Now using the same idea, we can see that there is not much difference for grouped dataframes. The only detail is that groups that are not ID columns are discarded. iex&gt; df = Explorer.DataFrame . new ( iex&gt; weekday : [ &quot;Monday&quot; , &quot;Tuesday&quot; , &quot;Wednesday&quot; , &quot;Thursday&quot; , &quot;Friday&quot; , &quot;Monday&quot; , &quot;Tuesday&quot; , &quot;Wednesday&quot; , &quot;Thursday&quot; , &quot;Friday&quot; ] , iex&gt; team : [ &quot;A&quot; , &quot;B&quot; , &quot;C&quot; , &quot;A&quot; , &quot;B&quot; , &quot;C&quot; , &quot;A&quot; , &quot;B&quot; , &quot;C&quot; , &quot;A&quot; ] , iex&gt; hour : [ 10 , 9 , 10 , 10 , 11 , 15 , 14 , 16 , 14 , 16 ] iex&gt; ) iex&gt; grouped = Explorer.DataFrame . group_by ( df , &quot;team&quot; ) iex&gt; Explorer.DataFrame . pivot_wider ( grouped , &quot;weekday&quot; , &quot;hour&quot; ) # Explorer.DataFrame &lt; Polars [ 3 x 6 ] Groups : [ &quot;team&quot; ] team string [ &quot;A&quot; , &quot;B&quot; , &quot;C&quot; ] Monday integer [ 10 , nil , 15 ] Tuesday integer [ 14 , 9 , nil ] Wednesday integer [ nil , 16 , 10 ] Thursday integer [ 10 , nil , 14 ] Friday integer [ 16 , 11 , nil ] &gt; In the following example the group &quot;weekday&quot; is going to be removed, because the column is going to be pivoted in multiple columns: iex&gt; df = Explorer.DataFrame . new ( iex&gt; weekday : [ &quot;Monday&quot; , &quot;Tuesday&quot; , &quot;Wednesday&quot; , &quot;Thursday&quot; , &quot;Friday&quot; , &quot;Monday&quot; , &quot;Tuesday&quot; , &quot;Wednesday&quot; , &quot;Thursday&quot; , &quot;Friday&quot; ] , iex&gt; team : [ &quot;A&quot; , &quot;B&quot; , &quot;C&quot; , &quot;A&quot; , &quot;B&quot; , &quot;C&quot; , &quot;A&quot; , &quot;B&quot; , &quot;C&quot; , &quot;A&quot; ] , iex&gt; hour : [ 10 , 9 , 10 , 10 , 11 , 15 , 14 , 16 , 14 , 16 ] iex&gt; ) iex&gt; grouped = Explorer.DataFrame . group_by ( df , &quot;weekday&quot; ) iex&gt; Explorer.DataFrame . pivot_wider ( grouped , &quot;weekday&quot; , &quot;hour&quot; ) # Explorer.DataFrame &lt; Polars [ 3 x 6 ] team string [ &quot;A&quot; , &quot;B&quot; , &quot;C&quot; ] Monday integer [ 10 , nil , 15 ] Tuesday integer [ 14 , 9 , nil ] Wednesday integer [ nil , 16 , 10 ] Thursday integer [ 10 , nil , 14 ] Friday integer [ 16 , 11 , nil ] &gt;","ref":"Explorer.DataFrame.html#pivot_wider/4","title":"Explorer.DataFrame.pivot_wider/4","type":"function"},{"doc":"Extracts a single column as a series. This is equivalent to df[field] for retrieving a single field. The returned series will have its :name field set to the column name. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . pull ( df , &quot;total&quot; ) # Explorer.Series &lt; Polars [ 1094 ] integer [ 2308 , 1254 , 32500 , 141 , 7924 , 41 , 143 , 51246 , 1150 , 684 , 106589 , 18408 , 8366 , 451 , 7981 , 16345 , 403 , 17192 , 30222 , 147 , 1388 , 166 , 133 , 5802 , 1278 , 114468 , 47 , 2237 , 12030 , 535 , 58 , 1367 , 145806 , 152 , 152 , 72 , 141 , 19703 , 2393248 , 20773 , 44 , 540 , 19 , 2064 , 1900 , 5501 , 10465 , 2102 , 30428 , 18122 , ... ] &gt; iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . pull ( df , 2 ) # Explorer.Series &lt; Polars [ 1094 ] integer [ 2308 , 1254 , 32500 , 141 , 7924 , 41 , 143 , 51246 , 1150 , 684 , 106589 , 18408 , 8366 , 451 , 7981 , 16345 , 403 , 17192 , 30222 , 147 , 1388 , 166 , 133 , 5802 , 1278 , 114468 , 47 , 2237 , 12030 , 535 , 58 , 1367 , 145806 , 152 , 152 , 72 , 141 , 19703 , 2393248 , 20773 , 44 , 540 , 19 , 2064 , 1900 , 5501 , 10465 , 2102 , 30428 , 18122 , ... ] &gt;","ref":"Explorer.DataFrame.html#pull/2","title":"Explorer.DataFrame.pull/2","type":"function"},{"doc":"Creates or modifies a single column. This is a simplified way to add or modify one column, accepting a series, tensor, or a list. If you are computing a series, it is preferrable to use mutate/2 or mutate_with/2 to compute the series and modify it in a single step, as it is more powerful and it handles both expressions and scalar values accordingly. If you are passing tensors or lists, they will be automatically converted to a series. By default, the new series will have the same dtype as the existing series, unless the :dtype option is given. If there is no existing series, one is inferred from the tensor/list. Examples iex&gt; df = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . put ( df , :b , Explorer.Series . transform ( df [ :a ] , fn n -&gt; n * 2 end ) ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] a integer [ 1 , 2 , 3 ] b integer [ 2 , 4 , 6 ] &gt; iex&gt; df = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . put ( df , :b , Explorer.Series . from_list ( [ 4 , 5 , 6 ] ) ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] a integer [ 1 , 2 , 3 ] b integer [ 4 , 5 , 6 ] &gt; Grouped examples If the dataframe is grouped, put/3 is going to ignore the groups. So the series must be of the same size of the entire dataframe. iex&gt; df = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] ) iex&gt; grouped = Explorer.DataFrame . group_by ( df , &quot;a&quot; ) iex&gt; series = Explorer.Series . from_list ( [ 9 , 8 , 7 ] ) iex&gt; Explorer.DataFrame . put ( grouped , :b , series ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] Groups : [ &quot;a&quot; ] a integer [ 1 , 2 , 3 ] b integer [ 9 , 8 , 7 ] &gt; Tensor examples You can also put tensors into the dataframe: iex&gt; df = Explorer.DataFrame . new ( [ ] ) iex&gt; Explorer.DataFrame . put ( df , :a , Nx . tensor ( [ 1 , 2 , 3 ] ) ) # Explorer.DataFrame &lt; Polars [ 3 x 1 ] a integer [ 1 , 2 , 3 ] &gt; You can specify which dtype the tensor represents. For example, a tensor of s64 represents integers by default, but it may also represent timestamps in microseconds from the Unix epoch: iex&gt; df = Explorer.DataFrame . new ( [ ] ) iex&gt; Explorer.DataFrame . put ( df , :a , Nx . tensor ( [ 1 , 2 , 3 ] ) , dtype : :datetime ) # Explorer.DataFrame &lt; Polars [ 3 x 1 ] a datetime [ 1970 - 01 - 01 00 : 00 : 00.000001 , 1970 - 01 - 01 00 : 00 : 00.000002 , 1970 - 01 - 01 00 : 00 : 00.000003 ] &gt; If there is already a column where we want to place the tensor, the column dtype will be automatically used, this means that updating dataframes in place while preserving their types is straight-forward: iex&gt; df = Explorer.DataFrame . new ( a : [ ~N[1970-01-01 00:00:00] ] ) iex&gt; Explorer.DataFrame . put ( df , :a , Nx . tensor ( 529550625987654 ) ) # Explorer.DataFrame &lt; Polars [ 1 x 1 ] a datetime [ 1986 - 10 - 13 01 : 23 : 45.987654 ] &gt; This is particularly useful for categorical columns: iex&gt; cat = Explorer.Series . from_list ( [ &quot;foo&quot; , &quot;bar&quot; , &quot;baz&quot; ] , dtype : :category ) iex&gt; df = Explorer.DataFrame . new ( a : cat ) iex&gt; Explorer.DataFrame . put ( df , :a , Nx . tensor ( [ 2 , 1 , 0 ] ) ) # Explorer.DataFrame &lt; Polars [ 3 x 1 ] a category [ &quot;baz&quot; , &quot;bar&quot; , &quot;foo&quot; ] &gt; On the other hand, if you try to put a floating tensor on an integer column, an error will be raised unless a dtype or dtype: :infer is given: iex&gt; df = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . put ( df , :a , Nx . tensor ( 1.0 , type : :f64 ) ) ** (ArgumentError) dtype integer expects a tensor of type {:s, 64} but got type {:f, 64} iex&gt; df = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . put ( df , :a , Nx . tensor ( 1.0 , type : :f64 ) , dtype : :float ) # Explorer.DataFrame &lt; Polars [ 3 x 1 ] a float [ 1.0 , 1.0 , 1.0 ] &gt; iex&gt; df = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . put ( df , :a , Nx . tensor ( 1.0 , type : :f64 ) , dtype : :infer ) # Explorer.DataFrame &lt; Polars [ 3 x 1 ] a float [ 1.0 , 1.0 , 1.0 ] &gt; List examples Similar to tensors, we can also put lists in the dataframe: iex&gt; df = Explorer.DataFrame . new ( [ ] ) iex&gt; Explorer.DataFrame . put ( df , :a , [ 1 , 2 , 3 ] ) # Explorer.DataFrame &lt; Polars [ 3 x 1 ] a integer [ 1 , 2 , 3 ] &gt; The same considerations as above apply.","ref":"Explorer.DataFrame.html#put/4","title":"Explorer.DataFrame.put/4","type":"function"},{"doc":"Renames columns. Renaming a column that is also a group is going to rename the group as well. To apply a function to a subset of columns, see rename_with/3 . Examples You can pass in a list of new names: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; ] , b : [ 1 , 3 , 1 ] ) iex&gt; Explorer.DataFrame . rename ( df , [ &quot;c&quot; , &quot;d&quot; ] ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] c string [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; ] d integer [ 1 , 3 , 1 ] &gt; Or you can rename individual columns using keyword args: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; ] , b : [ 1 , 3 , 1 ] ) iex&gt; Explorer.DataFrame . rename ( df , a : &quot;first&quot; ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] first string [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; ] b integer [ 1 , 3 , 1 ] &gt; Or you can rename individual columns using a map: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; ] , b : [ 1 , 3 , 1 ] ) iex&gt; Explorer.DataFrame . rename ( df , %{ &quot;a&quot; =&gt; &quot;first&quot; } ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] first string [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; ] b integer [ 1 , 3 , 1 ] &gt;","ref":"Explorer.DataFrame.html#rename/2","title":"Explorer.DataFrame.rename/2","type":"function"},{"doc":"Renames columns with a function. Renaming a column that is also a group is going to rename the group as well. Examples If no columns are specified, it will apply the function to all column names: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . rename_with ( df , &amp; String . upcase / 1 ) # Explorer.DataFrame &lt; Polars [ 1094 x 10 ] YEAR integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] COUNTRY string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , ... ] TOTAL integer [ 2308 , 1254 , 32500 , 141 , 7924 , ... ] SOLID_FUEL integer [ 627 , 117 , 332 , 0 , 0 , ... ] LIQUID_FUEL integer [ 1601 , 953 , 12381 , 141 , 3649 , ... ] GAS_FUEL integer [ 74 , 7 , 14565 , 0 , 374 , ... ] CEMENT integer [ 5 , 177 , 2598 , 0 , 204 , ... ] GAS_FLARING integer [ 0 , 0 , 2623 , 0 , 3697 , ... ] PER_CAPITA float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , ... ] BUNKER_FUELS integer [ 9 , 7 , 663 , 0 , 321 , ... ] &gt; A callback can be used to filter the column names that will be renamed, similarly to select/2 : iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . rename_with ( df , &amp; String . ends_with? ( &amp;1 , &quot;_fuel&quot; ) , &amp; String . trim_trailing ( &amp;1 , &quot;_fuel&quot; ) ) # Explorer.DataFrame &lt; Polars [ 1094 x 10 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , ... ] total integer [ 2308 , 1254 , 32500 , 141 , 7924 , ... ] solid integer [ 627 , 117 , 332 , 0 , 0 , ... ] liquid integer [ 1601 , 953 , 12381 , 141 , 3649 , ... ] gas integer [ 74 , 7 , 14565 , 0 , 374 , ... ] cement integer [ 5 , 177 , 2598 , 0 , 204 , ... ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 , ... ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , ... ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 , ... ] &gt; Or you can just pass in the list of column names you'd like to apply the function to: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . rename_with ( df , [ &quot;total&quot; , &quot;cement&quot; ] , &amp; String . upcase / 1 ) # Explorer.DataFrame &lt; Polars [ 1094 x 10 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , ... ] TOTAL integer [ 2308 , 1254 , 32500 , 141 , 7924 , ... ] solid_fuel integer [ 627 , 117 , 332 , 0 , 0 , ... ] liquid_fuel integer [ 1601 , 953 , 12381 , 141 , 3649 , ... ] gas_fuel integer [ 74 , 7 , 14565 , 0 , 374 , ... ] CEMENT integer [ 5 , 177 , 2598 , 0 , 204 , ... ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 , ... ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , ... ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 , ... ] &gt; Ranges, regexes, and functions are also accepted in column names, as in select/2 .","ref":"Explorer.DataFrame.html#rename_with/3","title":"Explorer.DataFrame.rename_with/3","type":"function"},{"doc":"Sample rows from a dataframe. If given an integer as the second argument, it will return N samples. If given a float, it will return that proportion of the series. Can sample with or without replacement. For grouped dataframes, sample will take into account the rows of each group, meaning that if you try to get N samples and you have G groups, you will get N * G rows. See the examples below. Options :replace - If set to true , each sample will be independent and therefore values may repeat. Required to be true for n greater then the number of rows in the dataframe or frac &gt; 1.0. (default: false ) :seed - An integer to be used as a random seed. If nil, a random value between 0 and 2^64 - 1 will be used. (default: nil ) :shuffle - If set to true , the resultant dataframe is going to be shuffle if the sample is equal to the size of the dataframe. (default: false ) Examples You can sample N rows: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . sample ( df , 3 , seed : 100 ) # Explorer.DataFrame &lt; Polars [ 3 x 10 ] year integer [ 2011 , 2012 , 2011 ] country string [ &quot;SERBIA&quot; , &quot;FALKLAND ISLANDS (MALVINAS)&quot; , &quot;SWAZILAND&quot; ] total integer [ 13422 , 15 , 286 ] solid_fuel integer [ 9355 , 3 , 102 ] liquid_fuel integer [ 2537 , 12 , 184 ] gas_fuel integer [ 1188 , 0 , 0 ] cement integer [ 342 , 0 , 0 ] gas_flaring integer [ 0 , 0 , 0 ] per_capita float [ 1.49 , 5.21 , 0.24 ] bunker_fuels integer [ 39 , 0 , 1 ] &gt; Or you can sample a proportion of rows: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . sample ( df , 0.03 , seed : 100 ) # Explorer.DataFrame &lt; Polars [ 32 x 10 ] year integer [ 2011 , 2012 , 2012 , 2013 , 2010 , ... ] country string [ &quot;URUGUAY&quot; , &quot;FRENCH POLYNESIA&quot; , &quot;ICELAND&quot; , &quot;PERU&quot; , &quot;TUNISIA&quot; , ... ] total integer [ 2117 , 222 , 491 , 15586 , 7543 , ... ] solid_fuel integer [ 1 , 0 , 96 , 784 , 15 , ... ] liquid_fuel integer [ 1943 , 222 , 395 , 7097 , 3138 , ... ] gas_fuel integer [ 40 , 0 , 0 , 3238 , 3176 , ... ] cement integer [ 132 , 0 , 0 , 1432 , 1098 , ... ] gas_flaring integer [ 0 , 0 , 0 , 3036 , 116 , ... ] per_capita float [ 0.63 , 0.81 , 1.52 , 0.51 , 0.71 , ... ] bunker_fuels integer [ 401 , 45 , 170 , 617 , 219 , ... ] &gt; Grouped examples In the following example we have the Iris dataset grouped by species, and we want to take a sample of two plants from each group. Since we have three species, the resultant dataframe is going to have six rows (2 * 3). iex&gt; df = Explorer.Datasets . iris ( ) iex&gt; grouped = Explorer.DataFrame . group_by ( df , &quot;species&quot; ) iex&gt; Explorer.DataFrame . sample ( grouped , 2 , seed : 100 ) # Explorer.DataFrame &lt; Polars [ 6 x 5 ] Groups : [ &quot;species&quot; ] sepal_length float [ 5.3 , 5.1 , 5.1 , 5.6 , 6.2 , ... ] sepal_width float [ 3.7 , 3.8 , 2.5 , 2.7 , 3.4 , ... ] petal_length float [ 1.5 , 1.9 , 3.0 , 4.2 , 5.4 , ... ] petal_width float [ 0.2 , 0.4 , 1.1 , 1.3 , 2.3 , ... ] species string [ &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-versicolor&quot; , &quot;Iris-versicolor&quot; , &quot;Iris-virginica&quot; , ... ] &gt; The behaviour is similar when you want to take a fraction of the rows from each group. The main difference is that each group can have more or less rows, depending on its size. iex&gt; df = Explorer.Datasets . iris ( ) iex&gt; grouped = Explorer.DataFrame . group_by ( df , &quot;species&quot; ) iex&gt; Explorer.DataFrame . sample ( grouped , 0.1 , seed : 100 ) # Explorer.DataFrame &lt; Polars [ 15 x 5 ] Groups : [ &quot;species&quot; ] sepal_length float [ 5.3 , 5.1 , 4.7 , 5.7 , 5.1 , ... ] sepal_width float [ 3.7 , 3.8 , 3.2 , 3.8 , 3.5 , ... ] petal_length float [ 1.5 , 1.9 , 1.3 , 1.7 , 1.4 , ... ] petal_width float [ 0.2 , 0.4 , 0.2 , 0.3 , 0.3 , ... ] species string [ &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , ... ] &gt;","ref":"Explorer.DataFrame.html#sample/3","title":"Explorer.DataFrame.sample/3","type":"function"},{"doc":"Selects a subset of columns by name. It's important to notice that groups are kept: you can't select off grouping columns. Examples You can select a single column: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . select ( df , &quot;a&quot; ) # Explorer.DataFrame &lt; Polars [ 3 x 1 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] &gt; Or a list of names: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . select ( df , [ &quot;a&quot; ] ) # Explorer.DataFrame &lt; Polars [ 3 x 1 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] &gt; You can also use a range or a list of integers: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] , c : [ 4 , 5 , 6 ] ) iex&gt; Explorer.DataFrame . select ( df , [ 0 , 1 ] ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] b integer [ 1 , 2 , 3 ] &gt; iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] , c : [ 4 , 5 , 6 ] ) iex&gt; Explorer.DataFrame . select ( df , 0 .. 1 ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] b integer [ 1 , 2 , 3 ] &gt; Or you can use a callback function that takes the dataframe's names as its first argument: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . select ( df , &amp; String . starts_with? ( &amp;1 , &quot;b&quot; ) ) # Explorer.DataFrame &lt; Polars [ 3 x 1 ] b integer [ 1 , 2 , 3 ] &gt; Or, if you prefer, a regex: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . select ( df , ~r/^b$/ ) # Explorer.DataFrame &lt; Polars [ 3 x 1 ] b integer [ 1 , 2 , 3 ] &gt; Or a callback function that takes names and types: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . select ( df , fn _name , type -&gt; type == :integer end ) # Explorer.DataFrame &lt; Polars [ 3 x 1 ] b integer [ 1 , 2 , 3 ] &gt; Grouped examples Columns that are also groups cannot be removed, you need to ungroup before removing these columns. iex&gt; df = Explorer.Datasets . iris ( ) iex&gt; grouped = Explorer.DataFrame . group_by ( df , &quot;species&quot; ) iex&gt; Explorer.DataFrame . select ( grouped , [ &quot;sepal_width&quot; ] ) # Explorer.DataFrame &lt; Polars [ 150 x 2 ] Groups : [ &quot;species&quot; ] sepal_width float [ 3.5 , 3.0 , 3.2 , 3.1 , 3.6 , ... ] species string [ &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , ... ] &gt;","ref":"Explorer.DataFrame.html#select/2","title":"Explorer.DataFrame.select/2","type":"function"},{"doc":"Gets the shape of the dataframe as a {height, width} tuple. This function works the same way for grouped dataframes, considering the entire dataframe in the counting of rows. Examples iex&gt; df = Explorer.DataFrame . new ( floats : [ 1.0 , 2.0 , 3.0 ] , ints : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . shape ( df ) { 3 , 2 }","ref":"Explorer.DataFrame.html#shape/1","title":"Explorer.DataFrame.shape/1","type":"function"},{"doc":"Change the order of the rows of a dataframe randomly. This function is going to ignore groups. Options :seed - An integer to be used as a random seed. If nil, a random value between 0 and 2^64 - 1 will be used. (default: nil ) Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . shuffle ( df , seed : 100 ) # Explorer.DataFrame &lt; Polars [ 1094 x 10 ] year integer [ 2014 , 2014 , 2014 , 2012 , 2010 , ... ] country string [ &quot;ISRAEL&quot; , &quot;ARGENTINA&quot; , &quot;NETHERLANDS&quot; , &quot;YEMEN&quot; , &quot;GRENADA&quot; , ... ] total integer [ 17617 , 55638 , 45624 , 5091 , 71 , ... ] solid_fuel integer [ 6775 , 1588 , 9070 , 129 , 0 , ... ] liquid_fuel integer [ 6013 , 25685 , 18272 , 4173 , 71 , ... ] gas_fuel integer [ 3930 , 26368 , 18010 , 414 , 0 , ... ] cement integer [ 898 , 1551 , 272 , 375 , 0 , ... ] gas_flaring integer [ 0 , 446 , 0 , 0 , 0 , ... ] per_capita float [ 2.22 , 1.29 , 2.7 , 0.2 , 0.68 , ... ] bunker_fuels integer [ 1011 , 2079 , 14210 , 111 , 4 , ... ] &gt;","ref":"Explorer.DataFrame.html#shuffle/2","title":"Explorer.DataFrame.shuffle/2","type":"function"},{"doc":"Slices rows at the given indices as a new dataframe. The indices may be a list or series of indices, or a range. A list of indices does not support negative numbers. Ranges may be negative on either end, which are then normalized. Note ranges in Elixir are inclusive. Slice works differently when a dataframe is grouped. It is going to consider the indices of each group instead of the entire dataframe. See the examples below. If your intention is to grab a portion of each group, prefer to use sample/3 instead. Examples iex&gt; df = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.DataFrame . slice ( df , [ 0 , 2 ] ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] a integer [ 1 , 3 ] b string [ &quot;a&quot; , &quot;c&quot; ] &gt; With a series iex&gt; df = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.DataFrame . slice ( df , Explorer.Series . from_list ( [ 0 , 2 ] ) ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] a integer [ 1 , 3 ] b string [ &quot;a&quot; , &quot;c&quot; ] &gt; With a range: iex&gt; df = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.DataFrame . slice ( df , 1 .. 2 ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] a integer [ 2 , 3 ] b string [ &quot;b&quot; , &quot;c&quot; ] &gt; With a range with negative first and last: iex&gt; df = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.DataFrame . slice ( df , - 2 .. - 1 ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] a integer [ 2 , 3 ] b string [ &quot;b&quot; , &quot;c&quot; ] &gt; Grouped examples We are going to once again use the Iris dataset. In this example we want to take elements at indexes 0 and 2: iex&gt; df = Explorer.Datasets . iris ( ) iex&gt; grouped = Explorer.DataFrame . group_by ( df , &quot;species&quot; ) iex&gt; Explorer.DataFrame . slice ( grouped , [ 0 , 2 ] ) # Explorer.DataFrame &lt; Polars [ 6 x 5 ] Groups : [ &quot;species&quot; ] sepal_length float [ 5.1 , 4.7 , 7.0 , 6.9 , 6.3 , ... ] sepal_width float [ 3.5 , 3.2 , 3.2 , 3.1 , 3.3 , ... ] petal_length float [ 1.4 , 1.3 , 4.7 , 4.9 , 6.0 , ... ] petal_width float [ 0.2 , 0.2 , 1.4 , 1.5 , 2.5 , ... ] species string [ &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-versicolor&quot; , &quot;Iris-versicolor&quot; , &quot;Iris-virginica&quot; , ... ] &gt; Now we want to take the first 3 rows of each group. This is going to work with the range 0..2 : iex&gt; df = Explorer.Datasets . iris ( ) iex&gt; grouped = Explorer.DataFrame . group_by ( df , &quot;species&quot; ) iex&gt; Explorer.DataFrame . slice ( grouped , 0 .. 2 ) # Explorer.DataFrame &lt; Polars [ 9 x 5 ] Groups : [ &quot;species&quot; ] sepal_length float [ 5.1 , 4.9 , 4.7 , 7.0 , 6.4 , ... ] sepal_width float [ 3.5 , 3.0 , 3.2 , 3.2 , 3.2 , ... ] petal_length float [ 1.4 , 1.4 , 1.3 , 4.7 , 4.5 , ... ] petal_width float [ 0.2 , 0.2 , 0.2 , 1.4 , 1.5 , ... ] species string [ &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-versicolor&quot; , &quot;Iris-versicolor&quot; , ... ] &gt;","ref":"Explorer.DataFrame.html#slice/2","title":"Explorer.DataFrame.slice/2","type":"function"},{"doc":"Subset a continuous set of rows. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . slice ( df , 1 , 2 ) # Explorer.DataFrame &lt; Polars [ 2 x 10 ] year integer [ 2010 , 2010 ] country string [ &quot;ALBANIA&quot; , &quot;ALGERIA&quot; ] total integer [ 1254 , 32500 ] solid_fuel integer [ 117 , 332 ] liquid_fuel integer [ 953 , 12381 ] gas_fuel integer [ 7 , 14565 ] cement integer [ 177 , 2598 ] gas_flaring integer [ 0 , 2623 ] per_capita float [ 0.43 , 0.9 ] bunker_fuels integer [ 7 , 663 ] &gt; Negative offsets count from the end of the series: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . slice ( df , - 10 , 2 ) # Explorer.DataFrame &lt; Polars [ 2 x 10 ] year integer [ 2014 , 2014 ] country string [ &quot;UNITED STATES OF AMERICA&quot; , &quot;URUGUAY&quot; ] total integer [ 1432855 , 1840 ] solid_fuel integer [ 450047 , 2 ] liquid_fuel integer [ 576531 , 1700 ] gas_fuel integer [ 390719 , 25 ] cement integer [ 11314 , 112 ] gas_flaring integer [ 4244 , 0 ] per_capita float [ 4.43 , 0.54 ] bunker_fuels integer [ 30722 , 251 ] &gt; If the length would run past the end of the dataframe, the result may be shorter than the length: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . slice ( df , - 10 , 20 ) # Explorer.DataFrame &lt; Polars [ 10 x 10 ] year integer [ 2014 , 2014 , 2014 , 2014 , 2014 , ... ] country string [ &quot;UNITED STATES OF AMERICA&quot; , &quot;URUGUAY&quot; , &quot;UZBEKISTAN&quot; , &quot;VANUATU&quot; , &quot;VENEZUELA&quot; , ... ] total integer [ 1432855 , 1840 , 28692 , 42 , 50510 , ... ] solid_fuel integer [ 450047 , 2 , 1677 , 0 , 204 , ... ] liquid_fuel integer [ 576531 , 1700 , 2086 , 42 , 28445 , ... ] gas_fuel integer [ 390719 , 25 , 23929 , 0 , 12731 , ... ] cement integer [ 11314 , 112 , 1000 , 0 , 1088 , ... ] gas_flaring integer [ 4244 , 0 , 0 , 0 , 8042 , ... ] per_capita float [ 4.43 , 0.54 , 0.97 , 0.16 , 1.65 , ... ] bunker_fuels integer [ 30722 , 251 , 0 , 10 , 1256 , ... ] &gt; Grouped examples We want to take the first 3 rows of each group. We need the offset 0 and the length 3: iex&gt; df = Explorer.Datasets . iris ( ) iex&gt; grouped = Explorer.DataFrame . group_by ( df , &quot;species&quot; ) iex&gt; Explorer.DataFrame . slice ( grouped , 0 , 3 ) # Explorer.DataFrame &lt; Polars [ 9 x 5 ] Groups : [ &quot;species&quot; ] sepal_length float [ 5.1 , 4.9 , 4.7 , 7.0 , 6.4 , ... ] sepal_width float [ 3.5 , 3.0 , 3.2 , 3.2 , 3.2 , ... ] petal_length float [ 1.4 , 1.4 , 1.3 , 4.7 , 4.5 , ... ] petal_width float [ 0.2 , 0.2 , 0.2 , 1.4 , 1.5 , ... ] species string [ &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-versicolor&quot; , &quot;Iris-versicolor&quot; , ... ] &gt; We can also pass a negative offset: iex&gt; df = Explorer.Datasets . iris ( ) iex&gt; grouped = Explorer.DataFrame . group_by ( df , &quot;species&quot; ) iex&gt; Explorer.DataFrame . slice ( grouped , - 6 , 3 ) # Explorer.DataFrame &lt; Polars [ 9 x 5 ] Groups : [ &quot;species&quot; ] sepal_length float [ 5.1 , 4.8 , 5.1 , 5.6 , 5.7 , ... ] sepal_width float [ 3.8 , 3.0 , 3.8 , 2.7 , 3.0 , ... ] petal_length float [ 1.9 , 1.4 , 1.6 , 4.2 , 4.2 , ... ] petal_width float [ 0.4 , 0.3 , 0.2 , 1.3 , 1.2 , ... ] species string [ &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-versicolor&quot; , &quot;Iris-versicolor&quot; , ... ] &gt;","ref":"Explorer.DataFrame.html#slice/3","title":"Explorer.DataFrame.slice/3","type":"function"},{"doc":"Summarise each group to a single row using Explorer.Query . To summarise, you must perform aggregation, defined in Explorer.Series , on the desired columns. The query is compiled and runs efficiently against the dataframe. This function performs aggregations based on groups, so at least one group is expected, and the query must contain at least one aggregation. It implicitly ungroups the resultant dataframe. Notice This is a macro. You must require Explorer.DataFrame before using it. See summarise_with/2 for a callback version of this function without Explorer.Query . Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; grouped_df = Explorer.DataFrame . group_by ( df , &quot;year&quot; ) iex&gt; Explorer.DataFrame . summarise ( grouped_df , total_max : max ( total ) , total_min : min ( total ) ) # Explorer.DataFrame &lt; Polars [ 5 x 3 ] year integer [ 2010 , 2011 , 2012 , 2013 , 2014 ] total_max integer [ 2393248 , 2654360 , 2734817 , 2797384 , 2806634 ] total_min integer [ 1 , 2 , 2 , 2 , 3 ] &gt; Suppose you want to get the mean petal length of each Iris species. You could do something like this: iex&gt; df = Explorer.Datasets . iris ( ) iex&gt; grouped_df = Explorer.DataFrame . group_by ( df , &quot;species&quot; ) iex&gt; Explorer.DataFrame . summarise ( grouped_df , mean_petal_length : mean ( petal_length ) ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] species string [ &quot;Iris-setosa&quot; , &quot;Iris-versicolor&quot; , &quot;Iris-virginica&quot; ] mean_petal_length float [ 1.464 , 4.26 , 5.552 ] &gt;","ref":"Explorer.DataFrame.html#summarise/2","title":"Explorer.DataFrame.summarise/2","type":"macro"},{"doc":"Summarise each group to a single row using a callback function. The callback receives a lazy dataframe. A lazy dataframe does hold any values, instead it stores all operations in order to execute all summarizations performantly. This is a callback version of summarise/2 . Examples iex&gt; alias Explorer . { DataFrame , Series } iex&gt; df = Explorer.Datasets . fossil_fuels ( ) |&gt; DataFrame . group_by ( &quot;year&quot; ) iex&gt; DataFrame . summarise_with ( df , &amp; [ total_max : Series . max ( &amp;1 [ &quot;total&quot; ] ) , countries : Series . n_distinct ( &amp;1 [ &quot;country&quot; ] ) ] ) # Explorer.DataFrame &lt; Polars [ 5 x 3 ] year integer [ 2010 , 2011 , 2012 , 2013 , 2014 ] total_max integer [ 2393248 , 2654360 , 2734817 , 2797384 , 2806634 ] countries integer [ 217 , 217 , 220 , 220 , 220 ] &gt;","ref":"Explorer.DataFrame.html#summarise_with/2","title":"Explorer.DataFrame.summarise_with/2","type":"function"},{"doc":"Display the DataFrame in a tabular fashion. Examples df = Explorer.Datasets.iris() Explorer.DataFrame.table(df) Explorer.DataFrame.table(df, limit: 1) Explorer.DataFrame.table(df, limit: :infinity)","ref":"Explorer.DataFrame.html#table/2","title":"Explorer.DataFrame.table/2","type":"function"},{"doc":"Returns the last n rows of the dataframe. By default it returns the last 5 rows. If the dataframe is using groups, then the last n rows of each group is returned. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . tail ( df ) # Explorer.DataFrame &lt; Polars [ 5 x 10 ] year integer [ 2014 , 2014 , 2014 , 2014 , 2014 ] country string [ &quot;VIET NAM&quot; , &quot;WALLIS AND FUTUNA ISLANDS&quot; , &quot;YEMEN&quot; , &quot;ZAMBIA&quot; , &quot;ZIMBABWE&quot; ] total integer [ 45517 , 6 , 6190 , 1228 , 3278 ] solid_fuel integer [ 19246 , 0 , 137 , 132 , 2097 ] liquid_fuel integer [ 12694 , 6 , 5090 , 797 , 1005 ] gas_fuel integer [ 5349 , 0 , 581 , 0 , 0 ] cement integer [ 8229 , 0 , 381 , 299 , 177 ] gas_flaring integer [ 0 , 0 , 0 , 0 , 0 ] per_capita float [ 0.49 , 0.44 , 0.24 , 0.08 , 0.22 ] bunker_fuels integer [ 761 , 1 , 153 , 33 , 9 ] &gt; iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . tail ( df , 2 ) # Explorer.DataFrame &lt; Polars [ 2 x 10 ] year integer [ 2014 , 2014 ] country string [ &quot;ZAMBIA&quot; , &quot;ZIMBABWE&quot; ] total integer [ 1228 , 3278 ] solid_fuel integer [ 132 , 2097 ] liquid_fuel integer [ 797 , 1005 ] gas_fuel integer [ 0 , 0 ] cement integer [ 299 , 177 ] gas_flaring integer [ 0 , 0 ] per_capita float [ 0.08 , 0.22 ] bunker_fuels integer [ 33 , 9 ] &gt; Grouped examples Using grouped dataframes makes tail/2 return n rows from each group. Here is an example using the Iris dataset, and returning two rows from each group: iex&gt; df = Explorer.Datasets . iris ( ) iex&gt; grouped = Explorer.DataFrame . group_by ( df , &quot;species&quot; ) iex&gt; Explorer.DataFrame . tail ( grouped , 2 ) # Explorer.DataFrame &lt; Polars [ 6 x 5 ] Groups : [ &quot;species&quot; ] sepal_length float [ 5.3 , 5.0 , 5.1 , 5.7 , 6.2 , ... ] sepal_width float [ 3.7 , 3.3 , 2.5 , 2.8 , 3.4 , ... ] petal_length float [ 1.5 , 1.4 , 3.0 , 4.1 , 5.4 , ... ] petal_width float [ 0.2 , 0.2 , 1.1 , 1.3 , 2.3 , ... ] species string [ &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-versicolor&quot; , &quot;Iris-versicolor&quot; , &quot;Iris-virginica&quot; , ... ] &gt;","ref":"Explorer.DataFrame.html#tail/2","title":"Explorer.DataFrame.tail/2","type":"function"},{"doc":"Converts a dataframe to a list of columns with lists as values. See to_series/2 if you want a list of columns with series as values. Note that this function does not take into account groups. Warning This is an expensive operation since it converts series to lists and doing so will copy the whole dataframe. Prefer to use the operations in this and the Explorer.Series module rather than the ones in Enum whenever possible, as Explorer is optimized for large series. Options :atom_keys - Configure if the resultant map should have atom keys. (default: false ) Examples iex&gt; df = Explorer.DataFrame . new ( ints : [ 1 , nil ] , floats : [ 1.0 , 2.0 ] ) iex&gt; Explorer.DataFrame . to_columns ( df ) %{ &quot;floats&quot; =&gt; [ 1.0 , 2.0 ] , &quot;ints&quot; =&gt; [ 1 , nil ] } iex&gt; df = Explorer.DataFrame . new ( floats : [ 1.0 , 2.0 ] , ints : [ 1 , nil ] ) iex&gt; Explorer.DataFrame . to_columns ( df , atom_keys : true ) %{ floats : [ 1.0 , 2.0 ] , ints : [ 1 , nil ] }","ref":"Explorer.DataFrame.html#to_columns/2","title":"Explorer.DataFrame.to_columns/2","type":"function"},{"doc":"Writes a dataframe to a delimited file. Groups are ignored if the dataframe is using any. Options :header - Should the column names be written as the first line of the file? (default: true ) :delimiter - A single character used to separate fields within a record. (default: &quot;,&quot; )","ref":"Explorer.DataFrame.html#to_csv/3","title":"Explorer.DataFrame.to_csv/3","type":"function"},{"doc":"Similar to to_csv/3 but raises if there is a problem reading the CSV.","ref":"Explorer.DataFrame.html#to_csv!/3","title":"Explorer.DataFrame.to_csv!/3","type":"function"},{"doc":"Writes a dataframe to an IPC file. Apache IPC is a language-agnostic columnar data structure that can be used to store dataframes. It excels as a format for quickly exchange data between different programming languages. Groups are ignored if the dataframe is using any. Options :compression - The compression algorithm to use when writing files. Supported options are: nil (uncompressed, default) :zstd :lz4 . :streaming - Tells the backend if it should use streaming, which means that the dataframe is not loaded to the memory at once, and instead it is written in chunks from a lazy dataframe. This option has no effect on eager - the default - dataframes. It defaults to true .","ref":"Explorer.DataFrame.html#to_ipc/3","title":"Explorer.DataFrame.to_ipc/3","type":"function"},{"doc":"Similar to to_ipc/3 , but raises in case of error.","ref":"Explorer.DataFrame.html#to_ipc!/3","title":"Explorer.DataFrame.to_ipc!/3","type":"function"},{"doc":"Writes a dataframe to an IPC Stream file. Arrow IPC Streams provide a streaming protocol or “format&quot; for sending an arbitrary length sequence of record batches. The format must be processed from start to end, and does not support random access. Options :compression - The compression algorithm to use when writing files. Supported options are: nil (uncompressed, default) :zstd :lz4 .","ref":"Explorer.DataFrame.html#to_ipc_stream/3","title":"Explorer.DataFrame.to_ipc_stream/3","type":"function"},{"doc":"Similar to to_ipc_stream/3 , but raises in case of error.","ref":"Explorer.DataFrame.html#to_ipc_stream!/3","title":"Explorer.DataFrame.to_ipc_stream!/3","type":"function"},{"doc":"Converts the dataframe to the lazy version of the current backend. If already lazy, this is a noop. Converting a grouped dataframe should return a lazy dataframe with groups.","ref":"Explorer.DataFrame.html#to_lazy/1","title":"Explorer.DataFrame.to_lazy/1","type":"function"},{"doc":"Writes a dataframe to a ndjson file. Groups are ignored if the dataframe is using any. NDJSON are files that contains JSON files separated by new lines. They are often used as structured logs.","ref":"Explorer.DataFrame.html#to_ndjson/3","title":"Explorer.DataFrame.to_ndjson/3","type":"function"},{"doc":"Similar to to_ndjson/3 , but raises in case of error.","ref":"Explorer.DataFrame.html#to_ndjson!/3","title":"Explorer.DataFrame.to_ndjson!/3","type":"function"},{"doc":"Writes a dataframe to a parquet file. Groups are ignored if the dataframe is using any. Options :compression - The compression algorithm to use when writing files. Where a compression level is available, this can be passed as a tuple, such as {:zstd, 3} . Supported options are: nil (uncompressed, default) :snappy :gzip (with levels 1-9) :brotli (with levels 1-11) :zstd (with levels -7-22) :lz4raw . :streaming - Tells the backend if it should use streaming, which means that the dataframe is not loaded to the memory at once, and instead it is written in chunks from a lazy dataframe. This option has no effect on eager - the default - dataframes. It defaults to true .","ref":"Explorer.DataFrame.html#to_parquet/3","title":"Explorer.DataFrame.to_parquet/3","type":"function"},{"doc":"Similar to to_parquet/3 , but raises in case of error.","ref":"Explorer.DataFrame.html#to_parquet!/3","title":"Explorer.DataFrame.to_parquet!/3","type":"function"},{"doc":"Converts a dataframe to a list of maps (rows). Warning This is an expensive operation since data is stored in a columnar format. You must avoid converting a dataframe to rows, as that will transform and copy the whole dataframe in memory. Prefer to use the operations in this module rather than the ones in Enum whenever possible, as this module is optimized for large series. Options :atom_keys - Configure if the resultant maps should have atom keys. (default: false ) Examples iex&gt; df = Explorer.DataFrame . new ( floats : [ 1.0 , 2.0 ] , ints : [ 1 , nil ] ) iex&gt; Explorer.DataFrame . to_rows ( df ) [ %{ &quot;floats&quot; =&gt; 1.0 , &quot;ints&quot; =&gt; 1 } , %{ &quot;floats&quot; =&gt; 2.0 , &quot;ints&quot; =&gt; nil } ] iex&gt; df = Explorer.DataFrame . new ( floats : [ 1.0 , 2.0 ] , ints : [ 1 , nil ] ) iex&gt; Explorer.DataFrame . to_rows ( df , atom_keys : true ) [ %{ floats : 1.0 , ints : 1 } , %{ floats : 2.0 , ints : nil } ]","ref":"Explorer.DataFrame.html#to_rows/2","title":"Explorer.DataFrame.to_rows/2","type":"function"},{"doc":"Converts a dataframe to a stream of maps (rows). Warning This is an expensive operation since data is stored in a columnar format. Prefer to use the operations in this module rather than the ones in Enum whenever possible, as this module is optimized for large series. Options :atom_keys - Configure if the resultant maps should have atom keys. (default: false ) :chunk_size - Number of rows passed to to_rows/2 while streaming over the data. (default: 1000 ) Examples iex&gt; df = Explorer.DataFrame . new ( floats : [ 1.0 , 2.0 ] , ints : [ 1 , nil ] ) iex&gt; Explorer.DataFrame . to_rows_stream ( df ) |&gt; Enum . map ( &amp; &amp;1 ) [ %{ &quot;floats&quot; =&gt; 1.0 , &quot;ints&quot; =&gt; 1 } , %{ &quot;floats&quot; =&gt; 2.0 , &quot;ints&quot; =&gt; nil } ] iex&gt; df = Explorer.DataFrame . new ( floats : [ 1.0 , 2.0 ] , ints : [ 1 , nil ] ) iex&gt; Explorer.DataFrame . to_rows_stream ( df , atom_keys : true ) |&gt; Enum . map ( &amp; &amp;1 ) [ %{ floats : 1.0 , ints : 1 } , %{ floats : 2.0 , ints : nil } ]","ref":"Explorer.DataFrame.html#to_rows_stream/2","title":"Explorer.DataFrame.to_rows_stream/2","type":"function"},{"doc":"Converts a dataframe to a list of columns with series as values. See to_columns/2 if you want a list of columns with lists as values. Note that this function does not take into account groups. Options :atom_keys - Configure if the resultant map should have atom keys. (default: false ) Examples iex&gt; df = Explorer.DataFrame . new ( ints : [ 1 , nil ] , floats : [ 1.0 , 2.0 ] ) iex&gt; map = Explorer.DataFrame . to_series ( df ) iex&gt; Explorer.Series . to_list ( map [ &quot;floats&quot; ] ) [ 1.0 , 2.0 ] iex&gt; Explorer.Series . to_list ( map [ &quot;ints&quot; ] ) [ 1 , nil ]","ref":"Explorer.DataFrame.html#to_series/2","title":"Explorer.DataFrame.to_series/2","type":"function"},{"doc":"Removes grouping variables. Accepts a list of group names. If groups is not specified, then all groups are removed. Examples Ungroups all by default: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; df = Explorer.DataFrame . group_by ( df , [ &quot;country&quot; , &quot;year&quot; ] ) iex&gt; Explorer.DataFrame . ungroup ( df ) # Explorer.DataFrame &lt; Polars [ 1094 x 10 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , ... ] total integer [ 2308 , 1254 , 32500 , 141 , 7924 , ... ] solid_fuel integer [ 627 , 117 , 332 , 0 , 0 , ... ] liquid_fuel integer [ 1601 , 953 , 12381 , 141 , 3649 , ... ] gas_fuel integer [ 74 , 7 , 14565 , 0 , 374 , ... ] cement integer [ 5 , 177 , 2598 , 0 , 204 , ... ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 , ... ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , ... ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 , ... ] &gt; Ungrouping a single column: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; df = Explorer.DataFrame . group_by ( df , [ &quot;country&quot; , &quot;year&quot; ] ) iex&gt; Explorer.DataFrame . ungroup ( df , &quot;country&quot; ) # Explorer.DataFrame &lt; Polars [ 1094 x 10 ] Groups : [ &quot;year&quot; ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , ... ] total integer [ 2308 , 1254 , 32500 , 141 , 7924 , ... ] solid_fuel integer [ 627 , 117 , 332 , 0 , 0 , ... ] liquid_fuel integer [ 1601 , 953 , 12381 , 141 , 3649 , ... ] gas_fuel integer [ 74 , 7 , 14565 , 0 , 374 , ... ] cement integer [ 5 , 177 , 2598 , 0 , 204 , ... ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 , ... ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , ... ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 , ... ] &gt; Lists, ranges, regexes, and functions are also accepted in column names, as in select/2 .","ref":"Explorer.DataFrame.html#ungroup/2","title":"Explorer.DataFrame.ungroup/2","type":"function"},{"doc":"Represents a column name or its index.","ref":"Explorer.DataFrame.html#t:column/0","title":"Explorer.DataFrame.column/0","type":"type"},{"doc":"Represents a column name as atom or string.","ref":"Explorer.DataFrame.html#t:column_name/0","title":"Explorer.DataFrame.column_name/0","type":"type"},{"doc":"Represents multiple column names as atoms or strings.","ref":"Explorer.DataFrame.html#t:column_names/0","title":"Explorer.DataFrame.column_names/0","type":"type"},{"doc":"Represents a column pair where the value is a column name or a column index, and the value is of type value .","ref":"Explorer.DataFrame.html#t:column_pairs/1","title":"Explorer.DataFrame.column_pairs/1","type":"type"},{"doc":"Represents multiple columns. The columns may be specified as one of: a list of columns indexes or names as atoms and strings a range a regex that keeps only the names matching the regex a one-arity function that receives column names and returns true for column names to keep a two-arity function that receives column names and types and returns true for column names to keep","ref":"Explorer.DataFrame.html#t:columns/0","title":"Explorer.DataFrame.columns/0","type":"type"},{"doc":"Represents a dataframe.","ref":"Explorer.DataFrame.html#t:t/0","title":"Explorer.DataFrame.t/0","type":"type"},{"doc":"Datasets used in examples and exploration. Note those datasets are not available inside Elixir releases (see mix release ), which is the usual way to deploy Elixir in production. Therefore, if you need one of those datasets in production, you must download the source files to your own application priv directory and load them yourself. For example: Explorer.DataFrame . from_csv! ( Application . app_dir ( :my_app , &quot;priv/iris.csv&quot; ) )","ref":"Explorer.Datasets.html","title":"Explorer.Datasets","type":"module"},{"doc":"CO2 emissions from fossil fuels since 2010, by country Citation Boden , T.A . , G . Marland , and R.J . Andres . 2013 . Global , Regional , and National Fossil - Fuel CO2 Emissions . Carbon Dioxide Information Analysis Center , Oak Ridge National Laboratory , U.S . Department of Energy , Oak Ridge , Tenn . , U.S.A . doi 10.3334 / CDIAC / 00001 _V2013","ref":"Explorer.Datasets.html#fossil_fuels/0","title":"Explorer.Datasets.fossil_fuels/0","type":"function"},{"doc":"Iris Dataset. This classic dataset was collected by Edgar Anderson in 1936 and made famous by R. A. Fisher's 1936 paper. It consists of several measurements of three species of Iris (Iris setosa, Iris virginica and Iris versicolor). Downloaded and modified from: https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data Citation Original Owners : R . A . Fisher ( 1936 ) The use of multiple measurements in taxonomic problems . Annals of Eugenics . 7 ( 2 ) : 179 – 188 . doi : 10.1111 / j . 1469 - 1809.1936 . tb02137 . x Iris . ( 1936 ) . UCI Machine Learning Repository .","ref":"Explorer.Datasets.html#iris/0","title":"Explorer.Datasets.iris/0","type":"function"},{"doc":"Wine Dataset. The data is the result of a chemical analysis of wines grown in the same region in Italy but derived from three different cultivars. The analysis determined the quantities of 13 constituents found in each of the three types of wines. Downloaded and modified from: https://archive.ics.uci.edu/ml/machine-learning-databases/wine/wine.data Citation Original Owners : Forina , M . et al , PARVUS - An Extendible Package for Data Exploration , Classification and Correlation . Institute of Pharmaceutical and Food Analysis and Technologies , Via Brigata Salerno , 16147 Genoa , Italy . Wine . ( 1991 ) . UCI Machine Learning Repository .","ref":"Explorer.Datasets.html#wine/0","title":"Explorer.Datasets.wine/0","type":"function"},{"doc":"High-level query for Explorer. Explorer.DataFrame vs DF All examples below assume you have defined aliased Explorer.DataFrame to DF as shown below: alias Explorer.DataFrame , as : DF Queries convert regular Elixir code which compile to efficient dataframes operations. Inside a query, only the limited set of Series operations are available and identifiers, such as strs and nums , represent dataframe column names: iex&gt; df = DF . new ( strs : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , nums : [ 1 , 2 , 3 ] ) iex&gt; DF . filter ( df , nums &gt; 2 ) # Explorer.DataFrame &lt; Polars [ 1 x 2 ] strs string [ &quot;c&quot; ] nums integer [ 3 ] &gt; If a column has unusual format, you can either rename it before-hand, or use col/1 inside queries: iex&gt; df = DF . new ( &quot;unusual nums&quot; : [ 1 , 2 , 3 ] ) iex&gt; DF . filter ( df , col ( &quot;unusual nums&quot; ) &gt; 2 ) # Explorer.DataFrame &lt; Polars [ 1 x 1 ] unusual nums integer [ 3 ] &gt; All operations from Explorer.Series are imported inside queries. This module also provides operators to use in queries, which are also imported into queries. Supported operations Queries are supported in the following operations: Explorer.DataFrame.arrange/2 Explorer.DataFrame.filter/2 Explorer.DataFrame.mutate/2 Explorer.DataFrame.summarise/2 Interpolation If you want to access variables defined outside of the query or get access to all Elixir constructs, you must use ^ : iex&gt; min = 2 iex&gt; df = DF . new ( strs : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , nums : [ 1 , 2 , 3 ] ) iex&gt; DF . filter ( df , nums &gt; ^ min ) # Explorer.DataFrame &lt; Polars [ 1 x 2 ] strs string [ &quot;c&quot; ] nums integer [ 3 ] &gt; iex&gt; min = 2 iex&gt; df = DF . new ( strs : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , nums : [ 1 , 2 , 3 ] ) iex&gt; DF . filter ( df , nums &lt; ^ if ( min &gt; 0 , do : 10 , else : - 10 ) ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] strs string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] nums integer [ 1 , 2 , 3 ] &gt; ^ can be used with col to access columns dynamically: iex&gt; df = DF . new ( &quot;unusual nums&quot; : [ 1 , 2 , 3 ] ) iex&gt; name = &quot;unusual nums&quot; iex&gt; DF . filter ( df , col ( ^ name ) &gt; 2 ) # Explorer.DataFrame &lt; Polars [ 1 x 1 ] unusual nums integer [ 3 ] &gt; Across and comprehensions Explorer.Query leverages the power behind Elixir for-comprehensions to provide a powerful syntax for traversing several columns in a dataframe at once. For example, imagine you want to standardization the data on the iris dataset, you could write this: iex&gt; iris = Explorer.Datasets . iris ( ) iex&gt; DF . mutate ( iris , ...&gt; sepal_width : ( sepal_width - mean ( sepal_width ) ) / variance ( sepal_width ) , ...&gt; sepal_length : ( sepal_length - mean ( sepal_length ) ) / variance ( sepal_length ) , ...&gt; petal_length : ( petal_length - mean ( petal_length ) ) / variance ( petal_length ) , ...&gt; petal_width : ( petal_width - mean ( petal_width ) ) / variance ( petal_width ) ...&gt; ) # Explorer.DataFrame &lt; Polars [ 150 x 5 ] sepal_length float [ - 1.0840606189132314 , - 1.3757361217598396 , - 1.6674116246064494 , - 1.8132493760297548 , - 1.2298983703365356 , ... ] sepal_width float [ 2.372289612531505 , - 0.28722789030650403 , 0.7765791108287006 , 0.24467561026109824 , 2.904193113099107 , ... ] petal_length float [ - 0.7576391687443842 , - 0.7576391687443842 , - 0.7897606710936372 , - 0.725517666395131 , - 0.7576391687443842 , ... ] petal_width float [ - 1.7147014356654704 , - 1.7147014356654704 , - 1.7147014356654704 , - 1.7147014356654704 , - 1.7147014356654704 , ... ] species string [ &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , ... ] &gt; While the code above does its job, it is quite repetitive. With across and for-comprehensions, we could instead write: iex&gt; iris = Explorer.Datasets . iris ( ) iex&gt; DF . mutate ( iris , ...&gt; for col &lt;- across ( [ &quot;sepal_width&quot; , &quot;sepal_length&quot; , &quot;petal_length&quot; , &quot;petal_width&quot; ] ) do ...&gt; { col . name , ( col - mean ( col ) ) / variance ( col ) } ...&gt; end ...&gt; ) # Explorer.DataFrame &lt; Polars [ 150 x 5 ] sepal_length float [ - 1.0840606189132314 , - 1.3757361217598396 , - 1.6674116246064494 , - 1.8132493760297548 , - 1.2298983703365356 , ... ] sepal_width float [ 2.372289612531505 , - 0.28722789030650403 , 0.7765791108287006 , 0.24467561026109824 , 2.904193113099107 , ... ] petal_length float [ - 0.7576391687443842 , - 0.7576391687443842 , - 0.7897606710936372 , - 0.725517666395131 , - 0.7576391687443842 , ... ] petal_width float [ - 1.7147014356654704 , - 1.7147014356654704 , - 1.7147014356654704 , - 1.7147014356654704 , - 1.7147014356654704 , ... ] species string [ &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , ... ] &gt; Which achieves the same result in a more concise and maintainable way. across/1 may receive any of the following input as arguments: a list of columns indexes or names as atoms and strings a range a regex that keeps only the names matching the regex For example, since we know the width and length columns are the first four, we could also have written (remember ranges in Elixir are inclusive): DF . mutate ( iris , for col &lt;- across ( 0 .. 3 ) do { col . name , ( col - mean ( col ) ) / variance ( col ) } end ) Or using a regex: DF . mutate ( iris , for col &lt;- across ( ~r/(sepal|petal)_(length|width)/ ) do { col . name , ( col - mean ( col ) ) / variance ( col ) } end ) For those new to Elixir, for-comprehensions have the following format: for PATTERN &lt;- GENERATOR , FILTER do EXPR end A comprehension filter is a mechanism that allows us to keep only columns based on additional properties, such as its dtype . A for-comprehension can have multiple generators and filters. For instance, if you want to apply standardization to all float columns, we can use across/0 to access all columns and then use a filter to keep only the float ones: iex&gt; iris = Explorer.Datasets . iris ( ) iex&gt; DF . mutate ( iris , ...&gt; for col &lt;- across ( ) , col . dtype == :float do ...&gt; { col . name , ( col - mean ( col ) ) / variance ( col ) } ...&gt; end ...&gt; ) # Explorer.DataFrame &lt; Polars [ 150 x 5 ] sepal_length float [ - 1.0840606189132314 , - 1.3757361217598396 , - 1.6674116246064494 , - 1.8132493760297548 , - 1.2298983703365356 , ... ] sepal_width float [ 2.372289612531505 , - 0.28722789030650403 , 0.7765791108287006 , 0.24467561026109824 , 2.904193113099107 , ... ] petal_length float [ - 0.7576391687443842 , - 0.7576391687443842 , - 0.7897606710936372 , - 0.725517666395131 , - 0.7576391687443842 , ... ] petal_width float [ - 1.7147014356654704 , - 1.7147014356654704 , - 1.7147014356654704 , - 1.7147014356654704 , - 1.7147014356654704 , ... ] species string [ &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , ... ] &gt; For-comprehensions works with all dataframe verbs. As we have seen above, for mutations we must return tuples as pair with the mutation name and its value. summarise works similarly. Note in both cases the name could also be generated dynamically. For example, to compute the mean per species, you could write: iex&gt; Explorer.Datasets . iris ( ) ...&gt; |&gt; DF . group_by ( &quot;species&quot; ) ...&gt; |&gt; DF . summarise ( ...&gt; for col &lt;- across ( ) , col . dtype == :float do ...&gt; { &quot; \#{ col . name } _mean&quot; , mean ( col ) } ...&gt; end ...&gt; ) # Explorer.DataFrame &lt; Polars [ 3 x 5 ] species string [ &quot;Iris-setosa&quot; , &quot;Iris-versicolor&quot; , &quot;Iris-virginica&quot; ] sepal_length_mean float [ 5.005999999999999 , 5.936 , 6.587999999999998 ] sepal_width_mean float [ 3.4180000000000006 , 2.7700000000000005 , 2.9739999999999998 ] petal_length_mean float [ 1.464 , 4.26 , 5.552 ] petal_width_mean float [ 0.2439999999999999 , 1.3259999999999998 , 2.026 ] &gt; arrange expects a list of columns to sort by, while for-comprehensions in filter generate a list of conditions, which are joined using and . For example, to filter all entries have both sepal and petal length above average, using a filter on the column name, one could write: iex&gt; iris = Explorer.Datasets . iris ( ) iex&gt; DF . filter ( iris , ...&gt; for col &lt;- across ( ) , String . ends_with? ( col . name , &quot;_length&quot; ) do ...&gt; col &gt; mean ( col ) ...&gt; end ...&gt; ) # Explorer.DataFrame &lt; Polars [ 70 x 5 ] sepal_length float [ 7.0 , 6.4 , 6.9 , 6.5 , 6.3 , ... ] sepal_width float [ 3.2 , 3.2 , 3.1 , 2.8 , 3.3 , ... ] petal_length float [ 4.7 , 4.5 , 4.9 , 4.6 , 4.7 , ... ] petal_width float [ 1.4 , 1.5 , 1.5 , 1.5 , 1.6 , ... ] species string [ &quot;Iris-versicolor&quot; , &quot;Iris-versicolor&quot; , &quot;Iris-versicolor&quot; , &quot;Iris-versicolor&quot; , &quot;Iris-versicolor&quot; , ... ] &gt; Do not mix comprehension and queries The filter inside a for-comprehension works at the meta level: it can only filter columns based on their names and dtypes, but not on their values. For example, this code does not make any sense and it will fail to compile: |&gt; DF . filter ( for col &lt;- across ( ) , col &gt; mean ( col ) do col end end ) Another way to think about it, the comprehensions traverse on the columns themselves, the contents inside the comprehension do-block traverse on the values inside the columns. Implementation details Queries simply become lazy dataframe operations at runtime. For example, the following query Explorer.DataFrame . filter ( df , nums &gt; 2 ) is equivalent to Explorer.DataFrame . filter_with ( df , fn df -&gt; Explorer.Series . greater ( df [ &quot;nums&quot; ] , 2 ) end ) This means that, whenever you want to generate queries programatically, you can fallback to the regular _with APIs.","ref":"Explorer.Query.html","title":"Explorer.Query","type":"module"},{"doc":"Delegate to Explorer.Series.pow/2 .","ref":"Explorer.Query.html#**/2","title":"Explorer.Query.**/2","type":"function"},{"doc":"Delegate to Explorer.Series.multiply/2 .","ref":"Explorer.Query.html#*/2","title":"Explorer.Query.*/2","type":"function"},{"doc":"Unary plus operator. Works with numbers and series.","ref":"Explorer.Query.html#+/1","title":"Explorer.Query.+/1","type":"function"},{"doc":"Delegate to Explorer.Series.add/2 .","ref":"Explorer.Query.html#+/2","title":"Explorer.Query.+/2","type":"function"},{"doc":"Unary minus operator. Works with numbers and series.","ref":"Explorer.Query.html#-/1","title":"Explorer.Query.-/1","type":"function"},{"doc":"Delegate to Explorer.Series.subtract/2 .","ref":"Explorer.Query.html#-/2","title":"Explorer.Query.-/2","type":"function"},{"doc":"Delegate to Explorer.Series.divide/2 .","ref":"Explorer.Query.html#//2","title":"Explorer.Query.//2","type":"function"},{"doc":"Delegate to Explorer.Series.not_equal/2 .","ref":"Explorer.Query.html#!=/2","title":"Explorer.Query.!=/2","type":"function"},{"doc":"Delegate to Explorer.Series.less/2 .","ref":"Explorer.Query.html#%3C/2","title":"Explorer.Query.</2","type":"function"},{"doc":"Delegate to Explorer.Series.less_equal/2 .","ref":"Explorer.Query.html#%3C=/2","title":"Explorer.Query.<=/2","type":"function"},{"doc":"String concatenation operator. Works with strings and series of strings. Examples DF . mutate ( df , name : first_name &lt;&gt; &quot; &quot; &lt;&gt; last_name ) If you want to convert concatenate non-string series, you can explicitly cast them to string before: DF . mutate ( df , name : cast ( year , :string ) &lt;&gt; &quot;-&quot; &lt;&gt; cast ( month , :string ) ) Or use format: DF . mutate ( df , name : format ( [ year , &quot;-&quot; , month ] ) )","ref":"Explorer.Query.html#%3C%3E/2","title":"Explorer.Query.<>/2","type":"macro"},{"doc":"Delegate to Explorer.Series.equal/2 .","ref":"Explorer.Query.html#==/2","title":"Explorer.Query.==/2","type":"function"},{"doc":"Delegate to Explorer.Series.greater/2 .","ref":"Explorer.Query.html#%3E/2","title":"Explorer.Query.>/2","type":"function"},{"doc":"Delegate to Explorer.Series.greater_equal/2 .","ref":"Explorer.Query.html#%3E=/2","title":"Explorer.Query.>=/2","type":"function"},{"doc":"Accesses all columns in the dataframe. This is the equivalent to across(0..-1//1) . See the module docs for more information.","ref":"Explorer.Query.html#across/0","title":"Explorer.Query.across/0","type":"macro"},{"doc":"Accesses the columns given by selector in the dataframe. across/1 is used as the generator inside for-comprehensions. See the module docs for more information.","ref":"Explorer.Query.html#across/1","title":"Explorer.Query.across/1","type":"macro"},{"doc":"Accesses a column by name. If your column name contains whitespace or start with uppercase letters, you can still access its name by using this macro: iex&gt; df = Explorer.DataFrame . new ( &quot;unusual nums&quot; : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . filter ( df , col ( &quot;unusual nums&quot; ) &gt; 2 ) # Explorer.DataFrame &lt; Polars [ 1 x 1 ] unusual nums integer [ 3 ] &gt; name must be an atom, a string, or an integer. It is equivalent to df[name] but inside a query. This can also be used if you want to access a column programatically, for example: iex&gt; df = Explorer.DataFrame . new ( nums : [ 1 , 2 , 3 ] ) iex&gt; name = :nums iex&gt; Explorer.DataFrame . filter ( df , col ( ^ name ) &gt; 2 ) # Explorer.DataFrame &lt; Polars [ 1 x 1 ] nums integer [ 3 ] &gt; For traversing multiple columns programatically, see across/0 and across/1 .","ref":"Explorer.Query.html#col/1","title":"Explorer.Query.col/1","type":"macro"},{"doc":"Builds an anonymous function from a query. This is the entry point used by Explorer.DataFrame.filter/2 and friends to convert queries into anonymous functions. See the moduledoc for more information.","ref":"Explorer.Query.html#query/1","title":"Explorer.Query.query/1","type":"macro"},{"doc":"The Series struct and API. A series can be of the following data types: :binary - Binary :boolean - Boolean :category - UTF-8 encoded binary but represented internally as integers :date - Date type that unwraps to Elixir.Date :datetime - DateTime type that unwraps to Elixir.NaiveDateTime :float - 64-bit floating point number :integer - 64-bit signed integer :string - UTF-8 encoded binary :time - Time type that unwraps to Elixir.Time A series must consist of a single data type only. Series may have nil values in them. The series dtype can be retrieved via the dtype/1 function or directly accessed as series.dtype . A series.name field is also available, but it is always nil unless the series is retrieved from a dataframe. Many functions only apply to certain dtypes. These functions may appear on distinct categories on the sidebar. Other functions may work on several datatypes, such as comparison functions. In such cases, a &quot;Supported dtypes&quot; section will be available in the function documentation. Creating series Series can be created using from_list/2 , from_binary/3 , and friends: Series can be made of numbers: iex&gt; Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) # Explorer.Series &lt; Polars [ 3 ] integer [ 1 , 2 , 3 ] &gt; Series are nullable, so you may also include nils: iex&gt; Explorer.Series . from_list ( [ 1.0 , nil , 2.5 , 3.1 ] ) # Explorer.Series &lt; Polars [ 4 ] float [ 1.0 , nil , 2.5 , 3.1 ] &gt; Any of the dtypes above are supported, such as strings: iex&gt; Explorer.Series . from_list ( [ &quot;foo&quot; , &quot;bar&quot; , &quot;baz&quot; ] ) # Explorer.Series &lt; Polars [ 3 ] string [ &quot;foo&quot; , &quot;bar&quot; , &quot;baz&quot; ] &gt;","ref":"Explorer.Series.html","title":"Explorer.Series","type":"module"},{"doc":"Computes the the arccosine of a number. The resultant series is going to be of dtype :float , in radians, with values between 0 and pi. Supported dtype :float Examples iex&gt; s = [ 1.0 , 0.0 , - 1.0 , - 0.7071067811865475 , 0.7071067811865475 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . acos ( s ) # Explorer.Series &lt; Polars [ 5 ] float [ 0.0 , 1.5707963267948966 , 3.141592653589793 , 2.356194490192345 , 0.7853981633974484 ] &gt;","ref":"Explorer.Series.html#acos/1","title":"Explorer.Series.acos/1","type":"function"},{"doc":"Adds right to left, element-wise. When mixing floats and integers, the resulting series will have dtype :float . At least one of the arguments must be a series. If both sizes are series, the series must have the same size or at last one of them must have size of 1. Supported dtypes :integer :float Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 4 , 5 , 6 ] ) iex&gt; Explorer.Series . add ( s1 , s2 ) # Explorer.Series &lt; Polars [ 3 ] integer [ 5 , 7 , 9 ] &gt; You can also use scalar values on both sides: iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . add ( s1 , 2 ) # Explorer.Series &lt; Polars [ 3 ] integer [ 3 , 4 , 5 ] &gt; iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . add ( 2 , s1 ) # Explorer.Series &lt; Polars [ 3 ] integer [ 3 , 4 , 5 ] &gt;","ref":"Explorer.Series.html#add/2","title":"Explorer.Series.add/2","type":"function"},{"doc":"Checks equality between two entire series. Examples iex&gt; s1 = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; ] ) iex&gt; s2 = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; ] ) iex&gt; Explorer.Series . all_equal ( s1 , s2 ) true iex&gt; s1 = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; ] ) iex&gt; s2 = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . all_equal ( s1 , s2 ) false iex&gt; s1 = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 ] ) iex&gt; Explorer.Series . all_equal ( s1 , s2 ) false","ref":"Explorer.Series.html#all_equal/2","title":"Explorer.Series.all_equal/2","type":"function"},{"doc":"Returns a boolean mask of left and right , element-wise. Both sizes must be series, the series must have the same size or at last one of them must have size of 1. Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; mask1 = Explorer.Series . greater ( s1 , 1 ) iex&gt; mask2 = Explorer.Series . less ( s1 , 3 ) iex&gt; Explorer.Series . and ( mask1 , mask2 ) # Explorer.Series &lt; Polars [ 3 ] boolean [ false , true , false ] &gt;","ref":"Explorer.Series.html#and/2","title":"Explorer.Series.and/2","type":"function"},{"doc":"Returns the indices that would sort the series. Options :direction - :asc or :desc , meaning &quot;ascending&quot; or &quot;descending&quot;, respectively. By default it sorts in acending order. :nils - :first or :last . By default it is :last if direction is :asc , and :first otherwise. Examples iex&gt; s = Explorer.Series . from_list ( [ 9 , 3 , 7 , 1 ] ) iex&gt; Explorer.Series . argsort ( s ) # Explorer.Series &lt; Polars [ 4 ] integer [ 3 , 1 , 2 , 0 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 9 , 3 , 7 , 1 ] ) iex&gt; Explorer.Series . argsort ( s , direction : :desc ) # Explorer.Series &lt; Polars [ 4 ] integer [ 0 , 2 , 1 , 3 ] &gt;","ref":"Explorer.Series.html#argsort/2","title":"Explorer.Series.argsort/2","type":"function"},{"doc":"Computes the the arcsine of a number. The resultant series is going to be of dtype :float , in radians, with values between -pi/2 and pi/2. Supported dtype :float Examples iex&gt; s = [ 1.0 , 0.0 , - 1.0 , - 0.7071067811865475 , 0.7071067811865475 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . asin ( s ) # Explorer.Series &lt; Polars [ 5 ] float [ 1.5707963267948966 , 0.0 , - 1.5707963267948966 , - 0.7853981633974482 , 0.7853981633974482 ] &gt;","ref":"Explorer.Series.html#asin/1","title":"Explorer.Series.asin/1","type":"function"},{"doc":"Returns the value of the series at the given index. This function will raise an error in case the index is out of bounds. Examples iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . at ( s , 2 ) &quot;c&quot; iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . at ( s , 4 ) ** (ArgumentError) index 4 out of bounds for series of size 3","ref":"Explorer.Series.html#at/2","title":"Explorer.Series.at/2","type":"function"},{"doc":"Takes every n th value in this series, returned as a new series. Examples iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . at_every ( s , 2 ) # Explorer.Series &lt; Polars [ 5 ] integer [ 1 , 3 , 5 , 7 , 9 ] &gt; If n is bigger than the size of the series, the result is a new series with only the first value of the supplied series. iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . at_every ( s , 20 ) # Explorer.Series &lt; Polars [ 1 ] integer [ 1 ] &gt;","ref":"Explorer.Series.html#at_every/2","title":"Explorer.Series.at_every/2","type":"function"},{"doc":"Computes the the arctangent of a number. The resultant series is going to be of dtype :float , in radians, with values between -pi/2 and pi/2. Supported dtype :float Examples iex&gt; s = [ 1.0 , 0.0 , - 1.0 , - 0.7071067811865475 , 0.7071067811865475 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . atan ( s ) # Explorer.Series &lt; Polars [ 5 ] float [ 0.7853981633974483 , 0.0 , - 0.7853981633974483 , - 0.6154797086703873 , 0.6154797086703873 ] &gt;","ref":"Explorer.Series.html#atan/1","title":"Explorer.Series.atan/1","type":"function"},{"doc":"Cast the series to another type. Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . cast ( s , :string ) # Explorer.Series &lt; Polars [ 3 ] string [ &quot;1&quot; , &quot;2&quot; , &quot;3&quot; ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . cast ( s , :float ) # Explorer.Series &lt; Polars [ 3 ] float [ 1.0 , 2.0 , 3.0 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . cast ( s , :date ) # Explorer.Series &lt; Polars [ 3 ] date [ 1970 - 01 - 02 , 1970 - 01 - 03 , 1970 - 01 - 04 ] &gt; Note that time is represented as an integer of microseconds since midnight. iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . cast ( s , :time ) # Explorer.Series &lt; Polars [ 3 ] time [ 00 : 00 : 00.000001 , 00 : 00 : 00.000002 , 00 : 00 : 00.000003 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 86399 * 1_000 * 1_000 ] ) iex&gt; Explorer.Series . cast ( s , :time ) # Explorer.Series &lt; Polars [ 1 ] time [ 23 : 59 : 59.000000 ] &gt; Note that datetime is represented as an integer of microseconds since Unix Epoch (1970-01-01 00:00:00). iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . cast ( s , :datetime ) # Explorer.Series &lt; Polars [ 3 ] datetime [ 1970 - 01 - 01 00 : 00 : 00.000001 , 1970 - 01 - 01 00 : 00 : 00.000002 , 1970 - 01 - 01 00 : 00 : 00.000003 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1649883642 * 1_000 * 1_000 ] ) iex&gt; Explorer.Series . cast ( s , :datetime ) # Explorer.Series &lt; Polars [ 1 ] datetime [ 2022 - 04 - 13 21 : 00 : 42.000000 ] &gt; You can also use cast/2 to categorise a string: iex&gt; s = Explorer.Series . from_list ( [ &quot;apple&quot; , &quot;banana&quot; , &quot;apple&quot; , &quot;lemon&quot; ] ) iex&gt; Explorer.Series . cast ( s , :category ) # Explorer.Series &lt; Polars [ 4 ] category [ &quot;apple&quot; , &quot;banana&quot; , &quot;apple&quot; , &quot;lemon&quot; ] &gt; cast/2 will return the series as a no-op if you try to cast to the same dtype. iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . cast ( s , :integer ) # Explorer.Series &lt; Polars [ 3 ] integer [ 1 , 2 , 3 ] &gt;","ref":"Explorer.Series.html#cast/2","title":"Explorer.Series.cast/2","type":"function"},{"doc":"Return a series with the category names of a categorical series. Each category has the index equal to its position. No order for the categories is guaranteed. Examples iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; , nil , &quot;a&quot; , &quot;c&quot; ] , dtype : :category ) iex&gt; Explorer.Series . categories ( s ) # Explorer.Series &lt; Polars [ 3 ] string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] &gt; iex&gt; s = Explorer.Series . from_list ( [ &quot;c&quot; , &quot;a&quot; , &quot;b&quot; ] , dtype : :category ) iex&gt; Explorer.Series . categories ( s ) # Explorer.Series &lt; Polars [ 3 ] string [ &quot;c&quot; , &quot;a&quot; , &quot;b&quot; ] &gt;","ref":"Explorer.Series.html#categories/1","title":"Explorer.Series.categories/1","type":"function"},{"doc":"Categorise a series of integers according to categories . This function receives a series of integers and convert them into the categories specified by the second argument. The second argument can be one of: a series with dtype :category . The integers will be indexes into the categories of the given series (returned by categories/1 ) a series with dtype :string . The integers will be indexes into the series itself a list of strings. The integers will be indexes into the list If you have a series of strings and you want to convert them into categories, invoke cast(series, :category) instead. Examples If a categorical series is given as second argument, we will extract its categories and map the integers into it: iex&gt; categories = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; , nil , &quot;a&quot; ] , dtype : :category ) iex&gt; indexes = Explorer.Series . from_list ( [ 0 , 2 , 1 , 0 , 2 ] ) iex&gt; Explorer.Series . categorise ( indexes , categories ) # Explorer.Series &lt; Polars [ 5 ] category [ &quot;a&quot; , &quot;c&quot; , &quot;b&quot; , &quot;a&quot; , &quot;c&quot; ] &gt; Otherwise, if a list of strings or a series of strings is given, they are considered to be the categories series itself: iex&gt; categories = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; indexes = Explorer.Series . from_list ( [ 0 , 2 , 1 , 0 , 2 ] ) iex&gt; Explorer.Series . categorise ( indexes , categories ) # Explorer.Series &lt; Polars [ 5 ] category [ &quot;a&quot; , &quot;c&quot; , &quot;b&quot; , &quot;a&quot; , &quot;c&quot; ] &gt; iex&gt; indexes = Explorer.Series . from_list ( [ 0 , 2 , 1 , 0 , 2 ] ) iex&gt; Explorer.Series . categorise ( indexes , [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) # Explorer.Series &lt; Polars [ 5 ] category [ &quot;a&quot; , &quot;c&quot; , &quot;b&quot; , &quot;a&quot; , &quot;c&quot; ] &gt; Elements that are not mapped to a category will become nil : iex&gt; indexes = Explorer.Series . from_list ( [ 0 , 2 , nil , 0 , 2 , 7 ] ) iex&gt; Explorer.Series . categorise ( indexes , [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) # Explorer.Series &lt; Polars [ 6 ] category [ &quot;a&quot; , &quot;c&quot; , nil , &quot;a&quot; , &quot;c&quot; , nil ] &gt;","ref":"Explorer.Series.html#categorise/2","title":"Explorer.Series.categorise/2","type":"function"},{"doc":"Ceil floating point series to highest integers smaller or equal to the float value. Examples iex&gt; s = Explorer.Series . from_list ( [ 1.124993 , 2.555321 , 3.995001 ] ) iex&gt; Explorer.Series . ceil ( s ) # Explorer.Series &lt; Polars [ 3 ] float [ 2.0 , 3.0 , 4.0 ] &gt;","ref":"Explorer.Series.html#ceil/1","title":"Explorer.Series.ceil/1","type":"function"},{"doc":"Finds the first non-missing element at each position. Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , nil , nil ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; s3 = Explorer.Series . from_list ( [ nil , nil , 3 , 4 ] ) iex&gt; Explorer.Series . coalesce ( [ s1 , s2 , s3 ] ) # Explorer.Series &lt; Polars [ 4 ] integer [ 1 , 2 , 3 , 4 ] &gt;","ref":"Explorer.Series.html#coalesce/1","title":"Explorer.Series.coalesce/1","type":"function"},{"doc":"Finds the first non-missing element at each position. coalesce(s1, s2) is equivalent to coalesce([s1, s2]) . Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , nil , 3 , nil ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . coalesce ( s1 , s2 ) # Explorer.Series &lt; Polars [ 4 ] integer [ 1 , 2 , 3 , 4 ] &gt; iex&gt; s1 = Explorer.Series . from_list ( [ &quot;foo&quot; , nil , &quot;bar&quot; , nil ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . coalesce ( s1 , s2 ) ** (ArgumentError) cannot invoke Explorer.Series.coalesce/2 with mismatched dtypes: :string and :integer","ref":"Explorer.Series.html#coalesce/2","title":"Explorer.Series.coalesce/2","type":"function"},{"doc":"Concatenate one or more series. The dtypes must match unless all are numeric, in which case all series will be downcast to float. Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 4 , 5 , 6 ] ) iex&gt; Explorer.Series . concat ( [ s1 , s2 ] ) # Explorer.Series &lt; Polars [ 6 ] integer [ 1 , 2 , 3 , 4 , 5 , 6 ] &gt; iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 4.0 , 5.0 , 6.4 ] ) iex&gt; Explorer.Series . concat ( [ s1 , s2 ] ) # Explorer.Series &lt; Polars [ 6 ] float [ 1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.4 ] &gt;","ref":"Explorer.Series.html#concat/1","title":"Explorer.Series.concat/1","type":"function"},{"doc":"Concatenate two series. concat(s1, s2) is equivalent to concat([s1, s2]) .","ref":"Explorer.Series.html#concat/2","title":"Explorer.Series.concat/2","type":"function"},{"doc":"Detects whether a string contains a substring. Examples iex&gt; s = Explorer.Series . from_list ( [ &quot;abc&quot; , &quot;def&quot; , &quot;bcd&quot; ] ) iex&gt; Explorer.Series . contains ( s , &quot;bc&quot; ) # Explorer.Series &lt; Polars [ 3 ] boolean [ true , false , true ] &gt;","ref":"Explorer.Series.html#contains/2","title":"Explorer.Series.contains/2","type":"function"},{"doc":"Computes the the cosine of a number (in radians). The resultant series is going to be of dtype :float , with values between 1 and -1. Supported dtype :float Examples iex&gt; pi = :math . pi ( ) iex&gt; s = [ - pi * 3 / 2 , - pi , - pi / 2 , - pi / 4 , 0 , pi / 4 , pi / 2 , pi , pi * 3 / 2 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . cos ( s ) # Explorer.Series &lt; Polars [ 9 ] float [ - 1.8369701987210297e-16 , - 1.0 , 6.123233995736766e-17 , 0.7071067811865476 , 1.0 , 0.7071067811865476 , 6.123233995736766e-17 , - 1.0 , - 1.8369701987210297e-16 ] &gt;","ref":"Explorer.Series.html#cos/1","title":"Explorer.Series.cos/1","type":"function"},{"doc":"Counts the number of elements in a series. In the context of lazy series and Explorer.Query , count/1 counts the elements inside the same group. If no group is in use, then count is going to return the size of the series. Examples iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . count ( s ) 3","ref":"Explorer.Series.html#count/1","title":"Explorer.Series.count/1","type":"function"},{"doc":"Calculates the cumulative maximum of the series. Optionally, can accumulate in reverse. Does not fill nil values. See fill_missing/2 . Supported dtypes :integer :float :date :time :datetime Examples iex&gt; s = [ 1 , 2 , 3 , 4 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . cumulative_max ( s ) # Explorer.Series &lt; Polars [ 4 ] integer [ 1 , 2 , 3 , 4 ] &gt; iex&gt; s = [ 1 , 2 , nil , 4 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . cumulative_max ( s ) # Explorer.Series &lt; Polars [ 4 ] integer [ 1 , 2 , nil , 4 ] &gt; iex&gt; s = [ ~T[03:00:02.000000] , ~T[02:04:19.000000] , nil , ~T[13:24:56.000000] ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . cumulative_max ( s ) # Explorer.Series &lt; Polars [ 4 ] time [ 03 : 00 : 02.000000 , 03 : 00 : 02.000000 , nil , 13 : 24 : 56.000000 ] &gt;","ref":"Explorer.Series.html#cumulative_max/2","title":"Explorer.Series.cumulative_max/2","type":"function"},{"doc":"Calculates the cumulative minimum of the series. Optionally, can accumulate in reverse. Does not fill nil values. See fill_missing/2 . Supported dtypes :integer :float :date :time :datetime Examples iex&gt; s = [ 1 , 2 , 3 , 4 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . cumulative_min ( s ) # Explorer.Series &lt; Polars [ 4 ] integer [ 1 , 1 , 1 , 1 ] &gt; iex&gt; s = [ 1 , 2 , nil , 4 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . cumulative_min ( s ) # Explorer.Series &lt; Polars [ 4 ] integer [ 1 , 1 , nil , 1 ] &gt; iex&gt; s = [ ~T[03:00:02.000000] , ~T[02:04:19.000000] , nil , ~T[13:24:56.000000] ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . cumulative_min ( s ) # Explorer.Series &lt; Polars [ 4 ] time [ 03 : 00 : 02.000000 , 02 : 04 : 19.000000 , nil , 02 : 04 : 19.000000 ] &gt;","ref":"Explorer.Series.html#cumulative_min/2","title":"Explorer.Series.cumulative_min/2","type":"function"},{"doc":"Calculates the cumulative sum of the series. Optionally, can accumulate in reverse. Does not fill nil values. See fill_missing/2 . Supported dtypes :integer :float :boolean Examples iex&gt; s = [ 1 , 2 , 3 , 4 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . cumulative_sum ( s ) # Explorer.Series &lt; Polars [ 4 ] integer [ 1 , 3 , 6 , 10 ] &gt; iex&gt; s = [ 1 , 2 , nil , 4 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . cumulative_sum ( s ) # Explorer.Series &lt; Polars [ 4 ] integer [ 1 , 3 , nil , 7 ] &gt;","ref":"Explorer.Series.html#cumulative_sum/2","title":"Explorer.Series.cumulative_sum/2","type":"function"},{"doc":"Returns a day-of-week number starting from Monday = 1. (ISO 8601 weekday number) Examples iex&gt; s = Explorer.Series . from_list ( [ ~D[2023-01-15] , ~D[2023-01-16] , ~D[2023-01-20] , nil ] ) iex&gt; Explorer.Series . day_of_week ( s ) # Explorer.Series &lt; Polars [ 4 ] integer [ 7 , 1 , 5 , nil ] &gt; It can also be called on a datetime series. iex&gt; s = Explorer.Series . from_list ( [ ~N[2023-01-15 00:00:00] , ~N[2023-01-16 23:59:59.999999] , ~N[2023-01-20 12:00:00] , nil ] ) iex&gt; Explorer.Series . day_of_week ( s ) # Explorer.Series &lt; Polars [ 4 ] integer [ 7 , 1 , 5 , nil ] &gt;","ref":"Explorer.Series.html#day_of_week/1","title":"Explorer.Series.day_of_week/1","type":"function"},{"doc":"Returns the unique values of the series. Examples iex&gt; s = [ 1 , 1 , 2 , 2 , 3 , 3 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . distinct ( s ) # Explorer.Series &lt; Polars [ 3 ] integer [ 1 , 2 , 3 ] &gt;","ref":"Explorer.Series.html#distinct/1","title":"Explorer.Series.distinct/1","type":"function"},{"doc":"Divides left by right, element-wise. The resulting series will have the dtype as :float . At least one of the arguments must be a series. If both sizes are series, the series must have the same size or at last one of them must have size of 1. Supported dtypes :integer :float Examples iex&gt; s1 = [ 10 , 10 , 10 ] |&gt; Explorer.Series . from_list ( ) iex&gt; s2 = [ 2 , 2 , 2 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . divide ( s1 , s2 ) # Explorer.Series &lt; Polars [ 3 ] float [ 5.0 , 5.0 , 5.0 ] &gt; iex&gt; s1 = [ 10 , 10 , 10 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . divide ( s1 , 2 ) # Explorer.Series &lt; Polars [ 3 ] float [ 5.0 , 5.0 , 5.0 ] &gt; iex&gt; s1 = [ 10 , 52 , 10 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . divide ( s1 , 2.5 ) # Explorer.Series &lt; Polars [ 3 ] float [ 4.0 , 20.8 , 4.0 ] &gt; iex&gt; s1 = [ 10 , 10 , 10 ] |&gt; Explorer.Series . from_list ( ) iex&gt; s2 = [ 2 , 0 , 2 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . divide ( s1 , s2 ) # Explorer.Series &lt; Polars [ 3 ] float [ 5.0 , Inf , 5.0 ] &gt;","ref":"Explorer.Series.html#divide/2","title":"Explorer.Series.divide/2","type":"function"},{"doc":"Converts all characters to lowercase. Examples iex&gt; s = Explorer.Series . from_list ( [ &quot;ABC&quot; , &quot;DEF&quot; , &quot;BCD&quot; ] ) iex&gt; Explorer.Series . downcase ( s ) # Explorer.Series &lt; Polars [ 3 ] string [ &quot;abc&quot; , &quot;def&quot; , &quot;bcd&quot; ] &gt;","ref":"Explorer.Series.html#downcase/1","title":"Explorer.Series.downcase/1","type":"function"},{"doc":"Returns the data type of the series. A series can be of the following data types: :float - 64-bit floating point number :integer - 64-bit signed integer :boolean - Boolean :string - UTF-8 encoded binary :date - Date type that unwraps to Elixir.Date :time - Time type that unwraps to Elixir.Time :datetime - DateTime type that unwraps to Elixir.NaiveDateTime Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . dtype ( s ) :integer iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , nil , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . dtype ( s ) :string","ref":"Explorer.Series.html#dtype/1","title":"Explorer.Series.dtype/1","type":"function"},{"doc":"Returns boolean mask of left == right , element-wise. At least one of the arguments must be a series. If both sizes are series, the series must have the same size or at last one of them must have size of 1. Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , 4 ] ) iex&gt; Explorer.Series . equal ( s1 , s2 ) # Explorer.Series &lt; Polars [ 3 ] boolean [ true , true , false ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . equal ( s , 1 ) # Explorer.Series &lt; Polars [ 3 ] boolean [ true , false , false ] &gt; iex&gt; s = Explorer.Series . from_list ( [ true , true , false ] ) iex&gt; Explorer.Series . equal ( s , true ) # Explorer.Series &lt; Polars [ 3 ] boolean [ true , true , false ] &gt; iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . equal ( s , &quot;a&quot; ) # Explorer.Series &lt; Polars [ 3 ] boolean [ true , false , false ] &gt; iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . equal ( s , ~D[1999-12-31] ) # Explorer.Series &lt; Polars [ 2 ] boolean [ false , true ] &gt; iex&gt; s = Explorer.Series . from_list ( [ ~N[2022-01-01 00:00:00] , ~N[2022-01-01 23:00:00] ] ) iex&gt; Explorer.Series . equal ( s , ~N[2022-01-01 00:00:00] ) # Explorer.Series &lt; Polars [ 2 ] boolean [ true , false ] &gt; iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . equal ( s , false ) ** (ArgumentError) cannot invoke Explorer.Series.equal/2 with mismatched dtypes: :string and false","ref":"Explorer.Series.html#equal/2","title":"Explorer.Series.equal/2","type":"function"},{"doc":"Calculate the exponentially weighted moving average, given smoothing factor alpha. Options :alpha - Optional smoothing factor which specifies the imporance given to most recent observations. It is a value such that, 0 &lt; alpha &lt;= 1. Defaults to 0.5. :adjust - If set to true, it corrects the bias introduced by smoothing process. Defaults to true . :min_periods - The number of values in the window that should be non-nil before computing a result. Defaults to 1 . :ignore_nils - If set to true, it ignore nulls in the calculation. Defaults to true . Examples iex&gt; s = 1 .. 5 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . ewm_mean ( s ) # Explorer.Series &lt; Polars [ 5 ] float [ 1.0 , 1.6666666666666667 , 2.4285714285714284 , 3.2666666666666666 , 4.161290322580645 ] &gt; iex&gt; s = 1 .. 5 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . ewm_mean ( s , alpha : 0.1 ) # Explorer.Series &lt; Polars [ 5 ] float [ 1.0 , 1.5263157894736843 , 2.070110701107011 , 2.6312881651642916 , 3.2097140484969833 ] &gt;","ref":"Explorer.Series.html#ewm_mean/2","title":"Explorer.Series.ewm_mean/2","type":"function"},{"doc":"Calculates the exponential of all elements.","ref":"Explorer.Series.html#exp/1","title":"Explorer.Series.exp/1","type":"function"},{"doc":"Fill missing values with the given strategy. If a scalar value is provided instead of a strategy atom, nil will be replaced with that value. It must be of the same dtype as the series. Strategies :forward - replace nil with the previous value :backward - replace nil with the next value :max - replace nil with the series maximum :min - replace nil with the series minimum :mean - replace nil with the series mean :nan (float only) - replace nil with NaN Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . fill_missing ( s , :forward ) # Explorer.Series &lt; Polars [ 4 ] integer [ 1 , 2 , 2 , 4 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . fill_missing ( s , :backward ) # Explorer.Series &lt; Polars [ 4 ] integer [ 1 , 2 , 4 , 4 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . fill_missing ( s , :max ) # Explorer.Series &lt; Polars [ 4 ] integer [ 1 , 2 , 4 , 4 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . fill_missing ( s , :min ) # Explorer.Series &lt; Polars [ 4 ] integer [ 1 , 2 , 1 , 4 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . fill_missing ( s , :mean ) # Explorer.Series &lt; Polars [ 4 ] integer [ 1 , 2 , 2 , 4 ] &gt; Values that belong to the series itself can also be added as missing: iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . fill_missing ( s , 3 ) # Explorer.Series &lt; Polars [ 4 ] integer [ 1 , 2 , 3 , 4 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , nil , &quot;d&quot; ] ) iex&gt; Explorer.Series . fill_missing ( s , &quot;c&quot; ) # Explorer.Series &lt; Polars [ 4 ] string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; , &quot;d&quot; ] &gt; Mismatched types will raise: iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . fill_missing ( s , &quot;foo&quot; ) ** (ArgumentError) cannot invoke Explorer.Series.fill_missing/2 with mismatched dtypes: :integer and &quot;foo&quot; Floats in particular accept missing values to be set to NaN, Inf, and -Inf: iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 4.0 ] ) iex&gt; Explorer.Series . fill_missing ( s , :nan ) # Explorer.Series &lt; Polars [ 4 ] float [ 1.0 , 2.0 , NaN , 4.0 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 4.0 ] ) iex&gt; Explorer.Series . fill_missing ( s , :infinity ) # Explorer.Series &lt; Polars [ 4 ] float [ 1.0 , 2.0 , Inf , 4.0 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 4.0 ] ) iex&gt; Explorer.Series . fill_missing ( s , :neg_infinity ) # Explorer.Series &lt; Polars [ 4 ] float [ 1.0 , 2.0 , - Inf , 4.0 ] &gt;","ref":"Explorer.Series.html#fill_missing/2","title":"Explorer.Series.fill_missing/2","type":"function"},{"doc":"Returns the first element of the series. Examples iex&gt; s = 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . first ( s ) 1","ref":"Explorer.Series.html#first/1","title":"Explorer.Series.first/1","type":"function"},{"doc":"Floor floating point series to lowest integers smaller or equal to the float value. Examples iex&gt; s = Explorer.Series . from_list ( [ 1.124993 , 2.555321 , 3.995001 ] ) iex&gt; Explorer.Series . floor ( s ) # Explorer.Series &lt; Polars [ 3 ] float [ 1.0 , 2.0 , 3.0 ] &gt;","ref":"Explorer.Series.html#floor/1","title":"Explorer.Series.floor/1","type":"function"},{"doc":"Returns a string series with all values concatenated. Examples iex&gt; s1 = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; s2 = Explorer.Series . from_list ( [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] ) iex&gt; s3 = Explorer.Series . from_list ( [ &quot;g&quot; , &quot;h&quot; , &quot;i&quot; ] ) iex&gt; Explorer.Series . format ( [ s1 , s2 , s3 ] ) # Explorer.Series &lt; Polars [ 3 ] string [ &quot;adg&quot; , &quot;beh&quot; , &quot;cfi&quot; ] &gt; iex&gt; s1 = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; , &quot;d&quot; ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , 3 , 4 ] ) iex&gt; s3 = Explorer.Series . from_list ( [ 1.5 , :nan , :infinity , :neg_infinity ] ) iex&gt; Explorer.Series . format ( [ s1 , &quot;/&quot; , s2 , &quot;/&quot; , s3 ] ) # Explorer.Series &lt; Polars [ 4 ] string [ &quot;a/1/1.5&quot; , &quot;b/2/NaN&quot; , &quot;c/3/inf&quot; , &quot;d/4/-inf&quot; ] &gt; iex&gt; s1 = Explorer.Series . from_list ( [ &lt;&lt; 1 &gt;&gt; , &lt;&lt; 239 , 191 , 19 &gt;&gt; ] , dtype : :binary ) iex&gt; s2 = Explorer.Series . from_list ( [ &lt;&lt; 3 &gt;&gt; , &lt;&lt; 4 &gt;&gt; ] , dtype : :binary ) iex&gt; Explorer.Series . format ( [ s1 , s2 ] ) ** (RuntimeError) External error: invalid utf-8 sequence","ref":"Explorer.Series.html#format/1","title":"Explorer.Series.format/1","type":"function"},{"doc":"Creates a new dataframe with unique values and the frequencies of each. Examples iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;a&quot; , &quot;b&quot; , &quot;c&quot; , &quot;c&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . frequencies ( s ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] values string [ &quot;c&quot; , &quot;a&quot; , &quot;b&quot; ] counts integer [ 3 , 2 , 1 ] &gt;","ref":"Explorer.Series.html#frequencies/1","title":"Explorer.Series.frequencies/1","type":"function"},{"doc":"Builds a series of dtype from binary . All binaries must be in native endianness. Options :backend - The backend to allocate the series on. Examples Integers and floats follow their native encoding: iex&gt; Explorer.Series . from_binary ( &lt;&lt; 1.0 :: float - 64 - native , 2.0 :: float - 64 - native &gt;&gt; , :float ) # Explorer.Series &lt; Polars [ 2 ] float [ 1.0 , 2.0 ] &gt; iex&gt; Explorer.Series . from_binary ( &lt;&lt; - 1 :: signed - 64 - native , 1 :: signed - 64 - native &gt;&gt; , :integer ) # Explorer.Series &lt; Polars [ 2 ] integer [ - 1 , 1 ] &gt; Booleans are unsigned integers: iex&gt; Explorer.Series . from_binary ( &lt;&lt; 1 , 0 , 1 &gt;&gt; , :boolean ) # Explorer.Series &lt; Polars [ 3 ] boolean [ true , false , true ] &gt; Dates are encoded as i32 representing days from the Unix epoch (1970-01-01): iex&gt; binary = &lt;&lt; - 719162 :: signed - 32 - native , 0 :: signed - 32 - native , 6129 :: signed - 32 - native &gt;&gt; iex&gt; Explorer.Series . from_binary ( binary , :date ) # Explorer.Series &lt; Polars [ 3 ] date [ 0001 - 01 - 01 , 1970 - 01 - 01 , 1986 - 10 - 13 ] &gt; Times are encoded as i64 representing microseconds from midnight: iex&gt; binary = &lt;&lt; 0 :: signed - 64 - native , 86399999999 :: signed - 64 - native &gt;&gt; iex&gt; Explorer.Series . from_binary ( binary , :time ) # Explorer.Series &lt; Polars [ 2 ] time [ 00 : 00 : 00.000000 , 23 : 59 : 59.999999 ] &gt; Datetimes are encoded as i64 representing microseconds from the Unix epoch (1970-01-01): iex&gt; binary = &lt;&lt; 0 :: signed - 64 - native , 529550625987654 :: signed - 64 - native &gt;&gt; iex&gt; Explorer.Series . from_binary ( binary , :datetime ) # Explorer.Series &lt; Polars [ 2 ] datetime [ 1970 - 01 - 01 00 : 00 : 00.000000 , 1986 - 10 - 13 01 : 23 : 45.987654 ] &gt;","ref":"Explorer.Series.html#from_binary/3","title":"Explorer.Series.from_binary/3","type":"function"},{"doc":"Creates a new series from a list. The list must consist of a single data type and nils. It is possible to have a list of only nil values. In this case, the list will have the :dtype of float. Options :backend - The backend to allocate the series on. :dtype - Cast the series to a given :dtype . By default this is nil , which means that Explorer will infer the type from the values in the list. Examples Explorer will infer the type from the values in the list: iex&gt; Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) # Explorer.Series &lt; Polars [ 3 ] integer [ 1 , 2 , 3 ] &gt; Series are nullable, so you may also include nils: iex&gt; Explorer.Series . from_list ( [ 1.0 , nil , 2.5 , 3.1 ] ) # Explorer.Series &lt; Polars [ 4 ] float [ 1.0 , nil , 2.5 , 3.1 ] &gt; A mix of integers and floats will be cast to a float: iex&gt; Explorer.Series . from_list ( [ 1 , 2.0 ] ) # Explorer.Series &lt; Polars [ 2 ] float [ 1.0 , 2.0 ] &gt; Floats series can accept NaN, Inf, and -Inf values: iex&gt; Explorer.Series . from_list ( [ 1.0 , 2.0 , :nan , 4.0 ] ) # Explorer.Series &lt; Polars [ 4 ] float [ 1.0 , 2.0 , NaN , 4.0 ] &gt; iex&gt; Explorer.Series . from_list ( [ 1.0 , 2.0 , :infinity , 4.0 ] ) # Explorer.Series &lt; Polars [ 4 ] float [ 1.0 , 2.0 , Inf , 4.0 ] &gt; iex&gt; Explorer.Series . from_list ( [ 1.0 , 2.0 , :neg_infinity , 4.0 ] ) # Explorer.Series &lt; Polars [ 4 ] float [ 1.0 , 2.0 , - Inf , 4.0 ] &gt; Trying to create a &quot;nil&quot; series will, by default, result in a series of floats: iex&gt; Explorer.Series . from_list ( [ nil , nil ] ) # Explorer.Series &lt; Polars [ 2 ] float [ nil , nil ] &gt; You can specify the desired dtype for a series with the :dtype option. iex&gt; Explorer.Series . from_list ( [ nil , nil ] , dtype : :integer ) # Explorer.Series &lt; Polars [ 2 ] integer [ nil , nil ] &gt; iex&gt; Explorer.Series . from_list ( [ 1 , nil ] , dtype : :string ) # Explorer.Series &lt; Polars [ 2 ] string [ &quot;1&quot; , nil ] &gt; The dtype option is particulary important if a :binary series is desired, because by default binary series will have the dtype of :string : iex&gt; Explorer.Series . from_list ( [ &lt;&lt; 228 , 146 , 51 &gt;&gt; , &lt;&lt; 42 , 209 , 236 &gt;&gt; ] , dtype : :binary ) # Explorer.Series &lt; Polars [ 2 ] binary [ &lt;&lt; 228 , 146 , 51 &gt;&gt; , &lt;&lt; 42 , 209 , 236 &gt;&gt; ] &gt; A series mixing UTF8 strings and binaries is possible: iex&gt; Explorer.Series . from_list ( [ &lt;&lt; 228 , 146 , 51 &gt;&gt; , &quot;Elixir&quot; ] , dtype : :binary ) # Explorer.Series &lt; Polars [ 2 ] binary [ &lt;&lt; 228 , 146 , 51 &gt;&gt; , &quot;Elixir&quot; ] &gt; Another option is to create a categorical series from a list of strings: iex&gt; Explorer.Series . from_list ( [ &quot;EUA&quot; , &quot;Brazil&quot; , &quot;Poland&quot; ] , dtype : :category ) # Explorer.Series &lt; Polars [ 3 ] category [ &quot;EUA&quot; , &quot;Brazil&quot; , &quot;Poland&quot; ] &gt; It is possible to create a series of :datetime from a list of microseconds since Unix Epoch. iex&gt; Explorer.Series . from_list ( [ 1649883642 * 1_000 * 1_000 ] , dtype : :datetime ) # Explorer.Series &lt; Polars [ 1 ] datetime [ 2022 - 04 - 13 21 : 00 : 42.000000 ] &gt; It is possible to create a series of :time from a list of microseconds since midnight. iex&gt; Explorer.Series . from_list ( [ 123 * 1_000 * 1_000 ] , dtype : :time ) # Explorer.Series &lt; Polars [ 1 ] time [ 00 : 02 : 03.000000 ] &gt; Mixing non-numeric data types will raise an ArgumentError: iex&gt; Explorer.Series . from_list ( [ 1 , &quot;a&quot; ] ) ** (ArgumentError) the value &quot;a&quot; does not match the inferred series dtype :integer","ref":"Explorer.Series.html#from_list/2","title":"Explorer.Series.from_list/2","type":"function"},{"doc":"Converts a Nx.Tensor.t/0 to a series. Warning Nx is an optional dependency. You will need to ensure it's installed to use this function. Options :backend - The backend to allocate the series on. :dtype - The dtype of the series, it must match the underlying tensor type. Examples Integers and floats: iex&gt; tensor = Nx . tensor ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . from_tensor ( tensor ) # Explorer.Series &lt; Polars [ 3 ] integer [ 1 , 2 , 3 ] &gt; iex&gt; tensor = Nx . tensor ( [ 1.0 , 2.0 , 3.0 ] , type : :f64 ) iex&gt; Explorer.Series . from_tensor ( tensor ) # Explorer.Series &lt; Polars [ 3 ] float [ 1.0 , 2.0 , 3.0 ] &gt; Unsigned 8-bit tensors are assumed to be booleans: iex&gt; tensor = Nx . tensor ( [ 1 , 0 , 1 ] , type : :u8 ) iex&gt; Explorer.Series . from_tensor ( tensor ) # Explorer.Series &lt; Polars [ 3 ] boolean [ true , false , true ] &gt; Signed 32-bit tensors are assumed to be dates: iex&gt; tensor = Nx . tensor ( [ - 719162 , 0 , 6129 ] , type : :s32 ) iex&gt; Explorer.Series . from_tensor ( tensor ) # Explorer.Series &lt; Polars [ 3 ] date [ 0001 - 01 - 01 , 1970 - 01 - 01 , 1986 - 10 - 13 ] &gt; Times are signed 64-bit and therefore must have their dtype explicitly given: iex&gt; tensor = Nx . tensor ( [ 0 , 86399999999 ] ) iex&gt; Explorer.Series . from_tensor ( tensor , dtype : :time ) # Explorer.Series &lt; Polars [ 2 ] time [ 00 : 00 : 00.000000 , 23 : 59 : 59.999999 ] &gt; Datetimes are signed 64-bit and therefore must have their dtype explicitly given: iex&gt; tensor = Nx . tensor ( [ 0 , 529550625987654 ] ) iex&gt; Explorer.Series . from_tensor ( tensor , dtype : :datetime ) # Explorer.Series &lt; Polars [ 2 ] datetime [ 1970 - 01 - 01 00 : 00 : 00.000000 , 1986 - 10 - 13 01 : 23 : 45.987654 ] &gt;","ref":"Explorer.Series.html#from_tensor/2","title":"Explorer.Series.from_tensor/2","type":"function"},{"doc":"Returns boolean mask of left &gt; right , element-wise. At least one of the arguments must be a series. If both sizes are series, the series must have the same size or at last one of them must have size of 1. Supported dtypes :integer :float :date :time :datetime Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , 4 ] ) iex&gt; Explorer.Series . greater ( s1 , s2 ) # Explorer.Series &lt; Polars [ 3 ] boolean [ false , false , false ] &gt;","ref":"Explorer.Series.html#greater/2","title":"Explorer.Series.greater/2","type":"function"},{"doc":"Returns boolean mask of left &gt;= right , element-wise. At least one of the arguments must be a series. If both sizes are series, the series must have the same size or at last one of them must have size of 1. Supported dtypes :integer :float :date :time :datetime Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , 4 ] ) iex&gt; Explorer.Series . greater_equal ( s1 , s2 ) # Explorer.Series &lt; Polars [ 3 ] boolean [ true , true , false ] &gt;","ref":"Explorer.Series.html#greater_equal/2","title":"Explorer.Series.greater_equal/2","type":"function"},{"doc":"Returns the first N elements of the series. Examples iex&gt; s = 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . head ( s ) # Explorer.Series &lt; Polars [ 10 ] integer [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] &gt;","ref":"Explorer.Series.html#head/2","title":"Explorer.Series.head/2","type":"function"},{"doc":"Checks if each element of the series in the left exists in the series in the right, returning a boolean mask. The series sizes do not have to match. Examples iex&gt; left = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; right = Explorer.Series . from_list ( [ 1 , 2 ] ) iex&gt; Series . in ( left , right ) # Explorer.Series &lt; Polars [ 3 ] boolean [ true , true , false ] &gt; iex&gt; left = Explorer.Series . from_list ( [ ~D[1970-01-01] , ~D[2000-01-01] , ~D[2010-04-17] ] ) iex&gt; right = Explorer.Series . from_list ( [ ~D[1970-01-01] , ~D[2010-04-17] ] ) iex&gt; Series . in ( left , right ) # Explorer.Series &lt; Polars [ 3 ] boolean [ true , false , true ] &gt;","ref":"Explorer.Series.html#in/2","title":"Explorer.Series.in/2","type":"function"},{"doc":"Returns the type of the underlying fixed-width binary representation. It returns something in the shape of {atom(), bits_size} or :none . It is often used in conjunction with to_iovec/1 and to_binary/1 . The possible iotypes are: :u for unsigned integers. :s for signed integers. :f for floats. Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 , 4 ] ) iex&gt; Explorer.Series . iotype ( s ) { :s , 64 } iex&gt; s = Explorer.Series . from_list ( [ ~D[1999-12-31] , ~D[1989-01-01] ] ) iex&gt; Explorer.Series . iotype ( s ) { :s , 32 } iex&gt; s = Explorer.Series . from_list ( [ ~T[00:00:00.000000] , ~T[23:59:59.999999] ] ) iex&gt; Explorer.Series . iotype ( s ) { :s , 64 } iex&gt; s = Explorer.Series . from_list ( [ 1.2 , 2.3 , 3.5 , 4.5 ] ) iex&gt; Explorer.Series . iotype ( s ) { :f , 64 } iex&gt; s = Explorer.Series . from_list ( [ true , false , true ] ) iex&gt; Explorer.Series . iotype ( s ) { :u , 8 } The operation returns :none for strings and binaries, as they do not provide a fixed-width binary representation: iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . iotype ( s ) :none However, if appropriate, you can convert them to categorical types, which will then return the index of each category: iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , dtype : :category ) iex&gt; Explorer.Series . iotype ( s ) { :u , 32 }","ref":"Explorer.Series.html#iotype/1","title":"Explorer.Series.iotype/1","type":"function"},{"doc":"Returns a mask of finite values. Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 0 , nil ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 0 , 2 , 0 , nil ] ) iex&gt; s3 = Explorer.Series . divide ( s1 , s2 ) iex&gt; Explorer.Series . is_finite ( s3 ) # Explorer.Series &lt; Polars [ 4 ] boolean [ false , true , false , nil ] &gt;","ref":"Explorer.Series.html#is_finite/1","title":"Explorer.Series.is_finite/1","type":"function"},{"doc":"Returns a mask of infinite values. Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , - 1 , 2 , 0 , nil ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 0 , 0 , 2 , 0 , nil ] ) iex&gt; s3 = Explorer.Series . divide ( s1 , s2 ) iex&gt; Explorer.Series . is_infinite ( s3 ) # Explorer.Series &lt; Polars [ 5 ] boolean [ true , true , false , false , nil ] &gt;","ref":"Explorer.Series.html#is_infinite/1","title":"Explorer.Series.is_infinite/1","type":"function"},{"doc":"Returns a mask of infinite values. Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 0 , nil ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 0 , 2 , 0 , nil ] ) iex&gt; s3 = Explorer.Series . divide ( s1 , s2 ) iex&gt; Explorer.Series . is_nan ( s3 ) # Explorer.Series &lt; Polars [ 4 ] boolean [ false , false , true , nil ] &gt;","ref":"Explorer.Series.html#is_nan/1","title":"Explorer.Series.is_nan/1","type":"function"},{"doc":"Returns a mask of nil values. Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . is_nil ( s ) # Explorer.Series &lt; Polars [ 4 ] boolean [ false , false , true , false ] &gt;","ref":"Explorer.Series.html#is_nil/1","title":"Explorer.Series.is_nil/1","type":"function"},{"doc":"Returns a mask of not nil values. Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . is_not_nil ( s ) # Explorer.Series &lt; Polars [ 4 ] boolean [ true , true , false , true ] &gt;","ref":"Explorer.Series.html#is_not_nil/1","title":"Explorer.Series.is_not_nil/1","type":"function"},{"doc":"Returns the last element of the series. Examples iex&gt; s = 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . last ( s ) 100","ref":"Explorer.Series.html#last/1","title":"Explorer.Series.last/1","type":"function"},{"doc":"Returns boolean mask of left &lt; right , element-wise. At least one of the arguments must be a series. If both sizes are series, the series must have the same size or at last one of them must have size of 1. Supported dtypes :integer :float :date :time :datetime Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , 4 ] ) iex&gt; Explorer.Series . less ( s1 , s2 ) # Explorer.Series &lt; Polars [ 3 ] boolean [ false , false , true ] &gt;","ref":"Explorer.Series.html#less/2","title":"Explorer.Series.less/2","type":"function"},{"doc":"Returns boolean mask of left &lt;= right , element-wise. At least one of the arguments must be a series. If both sizes are series, the series must have the same size or at last one of them must have size of 1. Supported dtypes :integer :float :date :time :datetime Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , 4 ] ) iex&gt; Explorer.Series . less_equal ( s1 , s2 ) # Explorer.Series &lt; Polars [ 3 ] boolean [ true , true , true ] &gt;","ref":"Explorer.Series.html#less_equal/2","title":"Explorer.Series.less_equal/2","type":"function"},{"doc":"Calculates the natural logarithm. The resultant series is going to be of dtype :float . See log/2 for passing a custom base. Supported dtypes :integer :float Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 , nil , 4 ] ) iex&gt; Explorer.Series . log ( s ) # Explorer.Series &lt; Polars [ 5 ] float [ 0.0 , 0.6931471805599453 , 1.0986122886681098 , nil , 1.3862943611198906 ] &gt;","ref":"Explorer.Series.html#log/1","title":"Explorer.Series.log/1","type":"function"},{"doc":"Calculates the logarithm on a given base. The resultant series is going to be of dtype :float . Supported dtypes :integer :float Examples iex&gt; s = Explorer.Series . from_list ( [ 8 , 16 , 32 ] ) iex&gt; Explorer.Series . log ( s , 2 ) # Explorer.Series &lt; Polars [ 3 ] float [ 3.0 , 4.0 , 5.0 ] &gt;","ref":"Explorer.Series.html#log/2","title":"Explorer.Series.log/2","type":"function"},{"doc":"Filters a series with a mask. Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ true , false , true ] ) iex&gt; Explorer.Series . mask ( s1 , s2 ) # Explorer.Series &lt; Polars [ 2 ] integer [ 1 , 3 ] &gt;","ref":"Explorer.Series.html#mask/2","title":"Explorer.Series.mask/2","type":"function"},{"doc":"Gets the maximum value of the series. Supported dtypes :integer :float :date :time :datetime Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . max ( s ) 3 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . max ( s ) 3.0 iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . max ( s ) ~D[2021-01-01] iex&gt; s = Explorer.Series . from_list ( [ ~N[2021-01-01 00:00:00] , ~N[1999-12-31 00:00:00] ] ) iex&gt; Explorer.Series . max ( s ) ~N[2021-01-01 00:00:00.000000] iex&gt; s = Explorer.Series . from_list ( [ ~T[00:02:03.000000] , ~T[00:05:04.000000] ] ) iex&gt; Explorer.Series . max ( s ) ~T[00:05:04.000000] iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . max ( s ) ** (ArgumentError) Explorer.Series.max/1 not implemented for dtype :string. Valid dtypes are [:integer, :float, :date, :time, :datetime]","ref":"Explorer.Series.html#max/1","title":"Explorer.Series.max/1","type":"function"},{"doc":"Gets the mean value of the series. Supported dtypes :integer :float Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . mean ( s ) 2.0 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . mean ( s ) 2.0 iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . mean ( s ) ** (ArgumentError) Explorer.Series.mean/1 not implemented for dtype :date. Valid dtypes are [:integer, :float]","ref":"Explorer.Series.html#mean/1","title":"Explorer.Series.mean/1","type":"function"},{"doc":"Gets the median value of the series. Supported dtypes :integer :float Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . median ( s ) 2.0 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . median ( s ) 2.0 iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . median ( s ) ** (ArgumentError) Explorer.Series.median/1 not implemented for dtype :date. Valid dtypes are [:integer, :float]","ref":"Explorer.Series.html#median/1","title":"Explorer.Series.median/1","type":"function"},{"doc":"Gets the minimum value of the series. Supported dtypes :integer :float :date :time :datetime Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . min ( s ) 1 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . min ( s ) 1.0 iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . min ( s ) ~D[1999-12-31] iex&gt; s = Explorer.Series . from_list ( [ ~N[2021-01-01 00:00:00] , ~N[1999-12-31 00:00:00] ] ) iex&gt; Explorer.Series . min ( s ) ~N[1999-12-31 00:00:00.000000] iex&gt; s = Explorer.Series . from_list ( [ ~T[00:02:03.000000] , ~T[00:05:04.000000] ] ) iex&gt; Explorer.Series . min ( s ) ~T[00:02:03.000000] iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . min ( s ) ** (ArgumentError) Explorer.Series.min/1 not implemented for dtype :string. Valid dtypes are [:integer, :float, :date, :time, :datetime]","ref":"Explorer.Series.html#min/1","title":"Explorer.Series.min/1","type":"function"},{"doc":"Multiplies left and right, element-wise. When mixing floats and integers, the resulting series will have dtype :float . At least one of the arguments must be a series. If both sizes are series, the series must have the same size or at last one of them must have size of 1. Supported dtypes :integer :float Examples iex&gt; s1 = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; s2 = 11 .. 20 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . multiply ( s1 , s2 ) # Explorer.Series &lt; Polars [ 10 ] integer [ 11 , 24 , 39 , 56 , 75 , 96 , 119 , 144 , 171 , 200 ] &gt; iex&gt; s1 = 1 .. 5 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . multiply ( s1 , 2 ) # Explorer.Series &lt; Polars [ 5 ] integer [ 2 , 4 , 6 , 8 , 10 ] &gt;","ref":"Explorer.Series.html#multiply/2","title":"Explorer.Series.multiply/2","type":"function"},{"doc":"Returns the number of unique values in the series. Examples iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; , &quot;b&quot; ] ) iex&gt; Explorer.Series . n_distinct ( s ) 2","ref":"Explorer.Series.html#n_distinct/1","title":"Explorer.Series.n_distinct/1","type":"function"},{"doc":"Counts the number of null elements in a series. Examples iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , nil , &quot;c&quot; , nil , nil ] ) iex&gt; Explorer.Series . nil_count ( s ) 3","ref":"Explorer.Series.html#nil_count/1","title":"Explorer.Series.nil_count/1","type":"function"},{"doc":"Negate the elements of a boolean series. Examples iex&gt; s1 = Explorer.Series . from_list ( [ true , false , false ] ) iex&gt; Explorer.Series . not ( s1 ) # Explorer.Series &lt; Polars [ 3 ] boolean [ false , true , true ] &gt;","ref":"Explorer.Series.html#not/1","title":"Explorer.Series.not/1","type":"function"},{"doc":"Returns boolean mask of left != right , element-wise. At least one of the arguments must be a series. If both sizes are series, the series must have the same size or at last one of them must have size of 1. Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , 4 ] ) iex&gt; Explorer.Series . not_equal ( s1 , s2 ) # Explorer.Series &lt; Polars [ 3 ] boolean [ false , false , true ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . not_equal ( s , 1 ) # Explorer.Series &lt; Polars [ 3 ] boolean [ false , true , true ] &gt; iex&gt; s = Explorer.Series . from_list ( [ true , true , false ] ) iex&gt; Explorer.Series . not_equal ( s , true ) # Explorer.Series &lt; Polars [ 3 ] boolean [ false , false , true ] &gt; iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . not_equal ( s , &quot;a&quot; ) # Explorer.Series &lt; Polars [ 3 ] boolean [ false , true , true ] &gt; iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . not_equal ( s , ~D[1999-12-31] ) # Explorer.Series &lt; Polars [ 2 ] boolean [ true , false ] &gt; iex&gt; s = Explorer.Series . from_list ( [ ~N[2022-01-01 00:00:00] , ~N[2022-01-01 23:00:00] ] ) iex&gt; Explorer.Series . not_equal ( s , ~N[2022-01-01 00:00:00] ) # Explorer.Series &lt; Polars [ 2 ] boolean [ false , true ] &gt; iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . not_equal ( s , false ) ** (ArgumentError) cannot invoke Explorer.Series.not_equal/2 with mismatched dtypes: :string and false","ref":"Explorer.Series.html#not_equal/2","title":"Explorer.Series.not_equal/2","type":"function"},{"doc":"Returns a boolean mask of left or right , element-wise. Both sizes must be series, the series must have the same size or at last one of them must have size of 1. Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; mask1 = Explorer.Series . less ( s1 , 2 ) iex&gt; mask2 = Explorer.Series . greater ( s1 , 2 ) iex&gt; Explorer.Series . or ( mask1 , mask2 ) # Explorer.Series &lt; Polars [ 3 ] boolean [ true , false , true ] &gt;","ref":"Explorer.Series.html#or/2","title":"Explorer.Series.or/2","type":"function"},{"doc":"Returns a boolean mask with true where the 'peaks' (series max or min, default max) are. Supported dtypes :integer :float :date :time :datetime Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 4 , 1 , 4 ] ) iex&gt; Explorer.Series . peaks ( s ) # Explorer.Series &lt; Polars [ 5 ] boolean [ false , false , true , false , true ] &gt; iex&gt; s = [ ~T[03:00:02.000000] , ~T[13:24:56.000000] , ~T[02:04:19.000000] ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . peaks ( s ) # Explorer.Series &lt; Polars [ 3 ] boolean [ false , true , false ] &gt;","ref":"Explorer.Series.html#peaks/2","title":"Explorer.Series.peaks/2","type":"function"},{"doc":"Raises a numeric series to the power of the exponent. At least one of the arguments must be a series. If both sizes are series, the series must have the same size or at last one of them must have size of 1. Supported dtypes :integer :float Examples iex&gt; s = [ 8 , 16 , 32 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . pow ( s , 2.0 ) # Explorer.Series &lt; Polars [ 3 ] float [ 64.0 , 256.0 , 1024.0 ] &gt; iex&gt; s = [ 2 , 4 , 6 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . pow ( s , 3 ) # Explorer.Series &lt; Polars [ 3 ] integer [ 8 , 64 , 216 ] &gt; iex&gt; s = [ 2 , 4 , 6 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . pow ( s , - 3.0 ) # Explorer.Series &lt; Polars [ 3 ] float [ 0.125 , 0.015625 , 0.004629629629629629 ] &gt; iex&gt; s = [ 1.0 , 2.0 , 3.0 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . pow ( s , 3.0 ) # Explorer.Series &lt; Polars [ 3 ] float [ 1.0 , 8.0 , 27.0 ] &gt; iex&gt; s = [ 2.0 , 4.0 , 6.0 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . pow ( s , 2 ) # Explorer.Series &lt; Polars [ 3 ] float [ 4.0 , 16.0 , 36.0 ] &gt;","ref":"Explorer.Series.html#pow/2","title":"Explorer.Series.pow/2","type":"function"},{"doc":"Gets the given quantile of the series. Supported dtypes :integer :float :date :time :datetime Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . quantile ( s , 0.2 ) 1 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . quantile ( s , 0.5 ) 2.0 iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . quantile ( s , 0.5 ) ~D[2021-01-01] iex&gt; s = Explorer.Series . from_list ( [ ~N[2021-01-01 00:00:00] , ~N[1999-12-31 00:00:00] ] ) iex&gt; Explorer.Series . quantile ( s , 0.5 ) ~N[2021-01-01 00:00:00.000000] iex&gt; s = Explorer.Series . from_list ( [ ~T[01:55:00.000000] , ~T[15:35:00.000000] , ~T[23:00:00.000000] ] ) iex&gt; Explorer.Series . quantile ( s , 0.5 ) ~T[15:35:00.000000] iex&gt; s = Explorer.Series . from_list ( [ true , false , true ] ) iex&gt; Explorer.Series . quantile ( s , 0.5 ) ** (ArgumentError) Explorer.Series.quantile/2 not implemented for dtype :boolean. Valid dtypes are [:integer, :float, :date, :time, :datetime]","ref":"Explorer.Series.html#quantile/2","title":"Explorer.Series.quantile/2","type":"function"},{"doc":"Element-wise integer division. At least one of the arguments must be a series. If both sizes are series, the series must have the same size or at last one of them must have size of 1. Supported dtype :integer Returns nil if there is a zero in the right-hand side. Examples iex&gt; s1 = [ 10 , 11 , 10 ] |&gt; Explorer.Series . from_list ( ) iex&gt; s2 = [ 2 , 2 , 2 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . quotient ( s1 , s2 ) # Explorer.Series &lt; Polars [ 3 ] integer [ 5 , 5 , 5 ] &gt; iex&gt; s1 = [ 10 , 11 , 10 ] |&gt; Explorer.Series . from_list ( ) iex&gt; s2 = [ 2 , 2 , 0 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . quotient ( s1 , s2 ) # Explorer.Series &lt; Polars [ 3 ] integer [ 5 , 5 , nil ] &gt; iex&gt; s1 = [ 10 , 12 , 15 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . quotient ( s1 , 3 ) # Explorer.Series &lt; Polars [ 3 ] integer [ 3 , 4 , 5 ] &gt;","ref":"Explorer.Series.html#quotient/2","title":"Explorer.Series.quotient/2","type":"function"},{"doc":"Computes the remainder of an element-wise integer division. At least one of the arguments must be a series. If both sizes are series, the series must have the same size or at last one of them must have size of 1. Supported dtype :integer Returns nil if there is a zero in the right-hand side. Examples iex&gt; s1 = [ 10 , 11 , 10 ] |&gt; Explorer.Series . from_list ( ) iex&gt; s2 = [ 2 , 2 , 2 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . remainder ( s1 , s2 ) # Explorer.Series &lt; Polars [ 3 ] integer [ 0 , 1 , 0 ] &gt; iex&gt; s1 = [ 10 , 11 , 10 ] |&gt; Explorer.Series . from_list ( ) iex&gt; s2 = [ 2 , 2 , 0 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . remainder ( s1 , s2 ) # Explorer.Series &lt; Polars [ 3 ] integer [ 0 , 1 , nil ] &gt; iex&gt; s1 = [ 10 , 11 , 9 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . remainder ( s1 , 3 ) # Explorer.Series &lt; Polars [ 3 ] integer [ 1 , 2 , 0 ] &gt;","ref":"Explorer.Series.html#remainder/2","title":"Explorer.Series.remainder/2","type":"function"},{"doc":"Replaces the contents of the given series by the one given in a tensor or list. The new series will have the same dtype and backend as the current series, but the size may not necessarily match. Tensor examples iex&gt; s = Explorer.Series . from_list ( [ 0 , 1 , 2 ] ) iex&gt; Explorer.Series . replace ( s , Nx . tensor ( [ 1 , 2 , 3 ] ) ) # Explorer.Series &lt; Polars [ 3 ] integer [ 1 , 2 , 3 ] &gt; This is particularly useful for categorical columns: iex&gt; s = Explorer.Series . from_list ( [ &quot;foo&quot; , &quot;bar&quot; , &quot;baz&quot; ] , dtype : :category ) iex&gt; Explorer.Series . replace ( s , Nx . tensor ( [ 2 , 1 , 0 ] ) ) # Explorer.Series &lt; Polars [ 3 ] category [ &quot;baz&quot; , &quot;bar&quot; , &quot;foo&quot; ] &gt; List examples Similar to tensors, we can also replace by lists: iex&gt; s = Explorer.Series . from_list ( [ 0 , 1 , 2 ] ) iex&gt; Explorer.Series . replace ( s , [ 1 , 2 , 3 , 4 , 5 ] ) # Explorer.Series &lt; Polars [ 5 ] integer [ 1 , 2 , 3 , 4 , 5 ] &gt; The same considerations as above apply.","ref":"Explorer.Series.html#replace/2","title":"Explorer.Series.replace/2","type":"function"},{"doc":"Reverses the series order. Example iex&gt; s = [ 1 , 2 , 3 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . reverse ( s ) # Explorer.Series &lt; Polars [ 3 ] integer [ 3 , 2 , 1 ] &gt;","ref":"Explorer.Series.html#reverse/1","title":"Explorer.Series.reverse/1","type":"function"},{"doc":"Round floating point series to given decimal places. Examples iex&gt; s = Explorer.Series . from_list ( [ 1.124993 , 2.555321 , 3.995001 ] ) iex&gt; Explorer.Series . round ( s , 2 ) # Explorer.Series &lt; Polars [ 3 ] float [ 1.12 , 2.56 , 4.0 ] &gt;","ref":"Explorer.Series.html#round/2","title":"Explorer.Series.round/2","type":"function"},{"doc":"Returns a random sample of the series. If given an integer as the second argument, it will return N samples. If given a float, it will return that proportion of the series. Can sample with or without replace. Options :replace - If set to true , each sample will be independent and therefore values may repeat. Required to be true for n greater then the number of rows in the series or frac &gt; 1.0. (default: false ) :seed - An integer to be used as a random seed. If nil, a random value between 0 and 2^64 − 1 will be used. (default: nil) :shuffle - In case the sample is equal to the size of the series, shuffle tells if the resultant series should be shuffled or if it should return the same series. (default: false ). Examples iex&gt; s = 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . sample ( s , 10 , seed : 100 ) # Explorer.Series &lt; Polars [ 10 ] integer [ 55 , 51 , 33 , 26 , 5 , 32 , 62 , 31 , 9 , 25 ] &gt; iex&gt; s = 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . sample ( s , 0.05 , seed : 100 ) # Explorer.Series &lt; Polars [ 5 ] integer [ 49 , 77 , 96 , 19 , 18 ] &gt; iex&gt; s = 1 .. 5 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . sample ( s , 7 , seed : 100 , replace : true ) # Explorer.Series &lt; Polars [ 7 ] integer [ 4 , 1 , 3 , 4 , 3 , 4 , 2 ] &gt; iex&gt; s = 1 .. 5 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . sample ( s , 1.2 , seed : 100 , replace : true ) # Explorer.Series &lt; Polars [ 6 ] integer [ 4 , 1 , 3 , 4 , 3 , 4 ] &gt; iex&gt; s = 0 .. 9 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . sample ( s , 1.0 , seed : 100 , shuffle : false ) # Explorer.Series &lt; Polars [ 10 ] integer [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] &gt; iex&gt; s = 0 .. 9 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . sample ( s , 1.0 , seed : 100 , shuffle : true ) # Explorer.Series &lt; Polars [ 10 ] integer [ 7 , 9 , 2 , 0 , 4 , 1 , 3 , 8 , 5 , 6 ] &gt;","ref":"Explorer.Series.html#sample/3","title":"Explorer.Series.sample/3","type":"function"},{"doc":"Returns a series from two series, based on a predicate. The resulting series is built by evaluating each element of predicate and returning either the corresponding element from on_true or on_false . predicate must be a boolean series. on_true and on_false must be a series of the same size as predicate or a series of size 1.","ref":"Explorer.Series.html#select/3","title":"Explorer.Series.select/3","type":"function"},{"doc":"Shifts series by offset with nil values. Positive offset shifts from first, negative offset shifts from last. Examples iex&gt; s = 1 .. 5 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . shift ( s , 2 ) # Explorer.Series &lt; Polars [ 5 ] integer [ nil , nil , 1 , 2 , 3 ] &gt; iex&gt; s = 1 .. 5 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . shift ( s , - 2 ) # Explorer.Series &lt; Polars [ 5 ] integer [ 3 , 4 , 5 , nil , nil ] &gt;","ref":"Explorer.Series.html#shift/2","title":"Explorer.Series.shift/2","type":"function"},{"doc":"Change the elements order randomly. Options :seed - An integer to be used as a random seed. If nil, a random value between 0 and 2^64 − 1 will be used. (default: nil) Examples iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . shuffle ( s , seed : 100 ) # Explorer.Series &lt; Polars [ 10 ] integer [ 8 , 10 , 3 , 1 , 5 , 2 , 4 , 9 , 6 , 7 ] &gt;","ref":"Explorer.Series.html#shuffle/2","title":"Explorer.Series.shuffle/2","type":"function"},{"doc":"Computes the the sine of a number (in radians). The resultant series is going to be of dtype :float , with values between 1 and -1. Supported dtype :float Examples iex&gt; pi = :math . pi ( ) iex&gt; s = [ - pi * 3 / 2 , - pi , - pi / 2 , - pi / 4 , 0 , pi / 4 , pi / 2 , pi , pi * 3 / 2 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . sin ( s ) # Explorer.Series &lt; Polars [ 9 ] float [ 1.0 , - 1.2246467991473532e-16 , - 1.0 , - 0.7071067811865475 , 0.0 , 0.7071067811865475 , 1.0 , 1.2246467991473532e-16 , - 1.0 ] &gt;","ref":"Explorer.Series.html#sin/1","title":"Explorer.Series.sin/1","type":"function"},{"doc":"Returns the size of the series. This is not allowed inside a lazy series. Use count/1 instead. Examples iex&gt; s = Explorer.Series . from_list ( [ ~D[1999-12-31] , ~D[1989-01-01] ] ) iex&gt; Explorer.Series . size ( s ) 2","ref":"Explorer.Series.html#size/1","title":"Explorer.Series.size/1","type":"function"},{"doc":"Slices the elements at the given indices as a new series. The indices may be either a list of indices or a range. A list of indices does not support negative numbers. Ranges may be negative on either end, which are then normalized. Note ranges in Elixir are inclusive. Examples iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . slice ( s , [ 0 , 2 ] ) # Explorer.Series &lt; Polars [ 2 ] string [ &quot;a&quot; , &quot;c&quot; ] &gt; iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . slice ( s , 1 .. 2 ) # Explorer.Series &lt; Polars [ 2 ] string [ &quot;b&quot; , &quot;c&quot; ] &gt; iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . slice ( s , - 2 .. - 1 ) # Explorer.Series &lt; Polars [ 2 ] string [ &quot;b&quot; , &quot;c&quot; ] &gt; iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . slice ( s , 3 .. 2 ) # Explorer.Series &lt; Polars [ 0 ] string [ ] &gt;","ref":"Explorer.Series.html#slice/2","title":"Explorer.Series.slice/2","type":"function"},{"doc":"Returns a slice of the series, with size elements starting at offset . Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 , 4 , 5 ] ) iex&gt; Explorer.Series . slice ( s , 1 , 2 ) # Explorer.Series &lt; Polars [ 2 ] integer [ 2 , 3 ] &gt; Negative offsets count from the end of the series: iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 , 4 , 5 ] ) iex&gt; Explorer.Series . slice ( s , - 3 , 2 ) # Explorer.Series &lt; Polars [ 2 ] integer [ 3 , 4 ] &gt; If the offset runs past the end of the series, the series is empty: iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 , 4 , 5 ] ) iex&gt; Explorer.Series . slice ( s , 10 , 3 ) # Explorer.Series &lt; Polars [ 0 ] integer [ ] &gt; If the size runs past the end of the series, the result may be shorter than the size: iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 , 4 , 5 ] ) iex&gt; Explorer.Series . slice ( s , - 3 , 4 ) # Explorer.Series &lt; Polars [ 3 ] integer [ 3 , 4 , 5 ] &gt;","ref":"Explorer.Series.html#slice/3","title":"Explorer.Series.slice/3","type":"function"},{"doc":"Sorts the series. Sorting is stable by default. Options :direction - :asc or :desc , meaning &quot;ascending&quot; or &quot;descending&quot;, respectively. By default it sorts in acending order. :nils - :first or :last . By default it is :last if direction is :asc , and :first otherwise. Examples iex&gt; s = Explorer.Series . from_list ( [ 9 , 3 , 7 , 1 ] ) iex&gt; Explorer.Series . sort ( s ) # Explorer.Series &lt; Polars [ 4 ] integer [ 1 , 3 , 7 , 9 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 9 , 3 , 7 , 1 ] ) iex&gt; Explorer.Series . sort ( s , direction : :desc ) # Explorer.Series &lt; Polars [ 4 ] integer [ 9 , 7 , 3 , 1 ] &gt;","ref":"Explorer.Series.html#sort/2","title":"Explorer.Series.sort/2","type":"function"},{"doc":"Gets the standard deviation of the series. Supported dtypes :integer :float Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . standard_deviation ( s ) 1.0 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . standard_deviation ( s ) 1.0 iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . standard_deviation ( s ) ** (ArgumentError) Explorer.Series.standard_deviation/1 not implemented for dtype :string. Valid dtypes are [:integer, :float]","ref":"Explorer.Series.html#standard_deviation/1","title":"Explorer.Series.standard_deviation/1","type":"function"},{"doc":"Subtracts right from left, element-wise. When mixing floats and integers, the resulting series will have dtype :float . At least one of the arguments must be a series. If both sizes are series, the series must have the same size or at last one of them must have size of 1. Supported dtypes :integer :float Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 4 , 5 , 6 ] ) iex&gt; Explorer.Series . subtract ( s1 , s2 ) # Explorer.Series &lt; Polars [ 3 ] integer [ - 3 , - 3 , - 3 ] &gt; You can also use scalar values on both sides: iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . subtract ( s1 , 2 ) # Explorer.Series &lt; Polars [ 3 ] integer [ - 1 , 0 , 1 ] &gt; iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . subtract ( 2 , s1 ) # Explorer.Series &lt; Polars [ 3 ] integer [ 1 , 0 , - 1 ] &gt;","ref":"Explorer.Series.html#subtract/2","title":"Explorer.Series.subtract/2","type":"function"},{"doc":"Gets the sum of the series. Supported dtypes :integer :float :boolean Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . sum ( s ) 6 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . sum ( s ) 6.0 iex&gt; s = Explorer.Series . from_list ( [ true , false , true ] ) iex&gt; Explorer.Series . sum ( s ) 2 iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . sum ( s ) ** (ArgumentError) Explorer.Series.sum/1 not implemented for dtype :date. Valid dtypes are [:integer, :float, :boolean]","ref":"Explorer.Series.html#sum/1","title":"Explorer.Series.sum/1","type":"function"},{"doc":"Returns the last N elements of the series. Examples iex&gt; s = 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . tail ( s ) # Explorer.Series &lt; Polars [ 10 ] integer [ 91 , 92 , 93 , 94 , 95 , 96 , 97 , 98 , 99 , 100 ] &gt;","ref":"Explorer.Series.html#tail/2","title":"Explorer.Series.tail/2","type":"function"},{"doc":"Computes the tangent of a number (in radians). The resultant series is going to be of dtype :float . Supported dtype :float Examples iex&gt; pi = :math . pi ( ) iex&gt; s = [ - pi * 3 / 2 , - pi , - pi / 2 , - pi / 4 , 0 , pi / 4 , pi / 2 , pi , pi * 3 / 2 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . tan ( s ) # Explorer.Series &lt; Polars [ 9 ] float [ - 5443746451065123.0 , 1.2246467991473532e-16 , - 1.633123935319537e16 , - 0.9999999999999999 , 0.0 , 0.9999999999999999 , 1.633123935319537e16 , - 1.2246467991473532e-16 , 5443746451065123.0 ] &gt;","ref":"Explorer.Series.html#tan/1","title":"Explorer.Series.tan/1","type":"function"},{"doc":"Returns a series as a fixed-width binary. This is a shortcut around to_iovec/1 . If possible, prefer to use to_iovec/1 as that avoids copying binaries. Examples iex&gt; series = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . to_binary ( series ) &lt;&lt; 1 :: signed - 64 - native , 2 :: signed - 64 - native , 3 :: signed - 64 - native &gt;&gt; iex&gt; series = Explorer.Series . from_list ( [ true , false , true ] ) iex&gt; Explorer.Series . to_binary ( series ) &lt;&lt; 1 , 0 , 1 &gt;&gt;","ref":"Explorer.Series.html#to_binary/1","title":"Explorer.Series.to_binary/1","type":"function"},{"doc":"Returns date component from the datetime series Examples iex&gt; s = Explorer.Series . from_list ( [ ~N[2023-01-15 00:00:00.000000] , ~N[2023-01-16 23:59:59.999999] , ~N[2023-01-20 12:00:00.000000] , nil ] ) iex&gt; Explorer.Series . to_date ( s ) # Explorer.Series &lt; Polars [ 4 ] date [ 2023 - 01 - 15 , 2023 - 01 - 16 , 2023 - 01 - 20 , nil ] &gt;","ref":"Explorer.Series.html#to_date/1","title":"Explorer.Series.to_date/1","type":"function"},{"doc":"Converts a series to an enumerable. The enumerable will lazily traverse the series. Warning You must avoid converting a series to enum, as that will copy the whole series in memory as you traverse it. Prefer to use the operations in this module rather than the ones in Enum whenever possible, as this module is optimized for large series. Examples iex&gt; series = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; series |&gt; Explorer.Series . to_enum ( ) |&gt; Enum . to_list ( ) [ 1 , 2 , 3 ]","ref":"Explorer.Series.html#to_enum/1","title":"Explorer.Series.to_enum/1","type":"function"},{"doc":"Returns a series as a list of fixed-width binaries. An io vector ( iovec ) is the Erlang VM term for a flat list of binaries. This is typically a reference to the in-memory representation of the series. If the whole series in contiguous in memory, then the list will have a single element. All binaries are in native endianness. This operation fails if the series has nil values. Use fill_missing/1 to handle them accordingly. To retrieve the type of the underlying io vector, use iotype/1 . To convert an iovec to a binary, you can use IO.iodata_to_binary/1 . Examples Integers and floats follow their native encoding: iex&gt; series = Explorer.Series . from_list ( [ - 1 , 0 , 1 ] ) iex&gt; Explorer.Series . to_iovec ( series ) [ &lt;&lt; - 1 :: signed - 64 - native , 0 :: signed - 64 - native , 1 :: signed - 64 - native &gt;&gt; ] iex&gt; series = Explorer.Series . from_list ( [ 1.0 , 2.0 , 3.0 ] ) iex&gt; Explorer.Series . to_iovec ( series ) [ &lt;&lt; 1.0 :: float - 64 - native , 2.0 :: float - 64 - native , 3.0 :: float - 64 - native &gt;&gt; ] Booleans are encoded as 0 and 1: iex&gt; series = Explorer.Series . from_list ( [ true , false , true ] ) iex&gt; Explorer.Series . to_iovec ( series ) [ &lt;&lt; 1 , 0 , 1 &gt;&gt; ] Dates are encoded as i32 representing days from the Unix epoch (1970-01-01): iex&gt; series = Explorer.Series . from_list ( [ ~D[0001-01-01] , ~D[1970-01-01] , ~D[1986-10-13] ] ) iex&gt; Explorer.Series . to_iovec ( series ) [ &lt;&lt; - 719162 :: signed - 32 - native , 0 :: signed - 32 - native , 6129 :: signed - 32 - native &gt;&gt; ] Times are encoded as i64 representing microseconds from midnight: iex&gt; series = Explorer.Series . from_list ( [ ~T[00:00:00.000000] , ~T[23:59:59.999999] ] ) iex&gt; Explorer.Series . to_iovec ( series ) [ &lt;&lt; 0 :: signed - 64 - native , 86399999999 :: signed - 64 - native &gt;&gt; ] Datetimes are encoded as i64 representing microseconds from the Unix epoch (1970-01-01): iex&gt; series = Explorer.Series . from_list ( [ ~N[0001-01-01 00:00:00] , ~N[1970-01-01 00:00:00] , ~N[1986-10-13 01:23:45.987654] ] ) iex&gt; Explorer.Series . to_iovec ( series ) [ &lt;&lt; - 62135596800000000 :: signed - 64 - native , 0 :: signed - 64 - native , 529550625987654 :: signed - 64 - native &gt;&gt; ] The operation raises for binaries and strings, as they do not provide a fixed-width binary representation: iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; , &quot;b&quot; ] ) iex&gt; Explorer.Series . to_iovec ( s ) ** (ArgumentError) cannot convert series of dtype :string into iovec However, if appropriate, you can convert them to categorical types, which will then return the index of each category: iex&gt; series = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; , &quot;b&quot; ] , dtype : :category ) iex&gt; Explorer.Series . to_iovec ( series ) [ &lt;&lt; 0 :: unsigned - 32 - native , 1 :: unsigned - 32 - native , 2 :: unsigned - 32 - native , 1 :: unsigned - 32 - native &gt;&gt; ]","ref":"Explorer.Series.html#to_iovec/1","title":"Explorer.Series.to_iovec/1","type":"function"},{"doc":"Converts a series to a list. Warning You must avoid converting a series to list, as that requires copying the whole series in memory. Prefer to use the operations in this module rather than the ones in Enum whenever possible, as this module is optimized for large series. Examples iex&gt; series = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . to_list ( series ) [ 1 , 2 , 3 ]","ref":"Explorer.Series.html#to_list/1","title":"Explorer.Series.to_list/1","type":"function"},{"doc":"Converts a series to a Nx.Tensor.t/0 . Note that Explorer.Series are automatically converted to tensors when passed to numerical definitions. The tensor type is given by iotype/1 . Warning Nx is an optional dependency. You will need to ensure it's installed to use this function. Options :backend - the Nx backend to allocate the tensor on Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . to_tensor ( s ) # Nx.Tensor &lt; s64 [ 3 ] [ 1 , 2 , 3 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ true , false , true ] ) iex&gt; Explorer.Series . to_tensor ( s ) # Nx.Tensor &lt; u8 [ 3 ] [ 1 , 0 , 1 ] &gt;","ref":"Explorer.Series.html#to_tensor/2","title":"Explorer.Series.to_tensor/2","type":"function"},{"doc":"Returns time component from the datetime series Examples iex&gt; s = Explorer.Series . from_list ( [ ~N[2023-01-15 00:00:00.000000] , ~N[2023-01-16 23:59:59.999999] , ~N[2023-01-20 12:00:00.000000] , nil ] ) iex&gt; Explorer.Series . to_time ( s ) # Explorer.Series &lt; Polars [ 4 ] time [ 00 : 00 : 00.000000 , 23 : 59 : 59.999999 , 12 : 00 : 00.000000 , nil ] &gt;","ref":"Explorer.Series.html#to_time/1","title":"Explorer.Series.to_time/1","type":"function"},{"doc":"Returns an Explorer.Series where each element is the result of invoking fun on each corresponding element of series . This is an expensive operation meant to enable the use of arbitrary Elixir functions against any backend. The implementation will vary by backend but in most (all?) cases will require converting to an Elixir.List , applying Enum.map/2 , and then converting back to an Explorer.Series . Examples iex&gt; s = Explorer.Series . from_list ( [ &quot;this &quot; , &quot; is&quot; , &quot;great &quot; ] ) iex&gt; Explorer.Series . transform ( s , &amp; String . trim / 1 ) # Explorer.Series &lt; Polars [ 3 ] string [ &quot;this&quot; , &quot;is&quot; , &quot;great&quot; ] &gt; iex&gt; s = Explorer.Series . from_list ( [ &quot;this&quot; , &quot;is&quot; , &quot;great&quot; ] ) iex&gt; Explorer.Series . transform ( s , &amp; String . length / 1 ) # Explorer.Series &lt; Polars [ 3 ] integer [ 4 , 2 , 5 ] &gt;","ref":"Explorer.Series.html#transform/2","title":"Explorer.Series.transform/2","type":"function"},{"doc":"Returns a string where all leading and trailing Unicode whitespaces have been removed. Examples iex&gt; s = Explorer.Series . from_list ( [ &quot; abc&quot; , &quot;def &quot; , &quot; bcd&quot; ] ) iex&gt; Explorer.Series . trim ( s ) # Explorer.Series &lt; Polars [ 3 ] string [ &quot;abc&quot; , &quot;def&quot; , &quot;bcd&quot; ] &gt;","ref":"Explorer.Series.html#trim/1","title":"Explorer.Series.trim/1","type":"function"},{"doc":"Returns a string where all leading Unicode whitespaces have been removed. Examples iex&gt; s = Explorer.Series . from_list ( [ &quot; abc&quot; , &quot;def &quot; , &quot; bcd&quot; ] ) iex&gt; Explorer.Series . trim_leading ( s ) # Explorer.Series &lt; Polars [ 3 ] string [ &quot;abc&quot; , &quot;def &quot; , &quot;bcd&quot; ] &gt;","ref":"Explorer.Series.html#trim_leading/1","title":"Explorer.Series.trim_leading/1","type":"function"},{"doc":"Returns a string where all trailing Unicode whitespaces have been removed. Examples iex&gt; s = Explorer.Series . from_list ( [ &quot; abc&quot; , &quot;def &quot; , &quot; bcd&quot; ] ) iex&gt; Explorer.Series . trim_trailing ( s ) # Explorer.Series &lt; Polars [ 3 ] string [ &quot; abc&quot; , &quot;def&quot; , &quot; bcd&quot; ] &gt;","ref":"Explorer.Series.html#trim_trailing/1","title":"Explorer.Series.trim_trailing/1","type":"function"},{"doc":"Returns the unique values of the series, but does not maintain order. Faster than distinct/1 . Examples iex&gt; s = [ 1 , 1 , 2 , 2 , 3 , 3 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . unordered_distinct ( s )","ref":"Explorer.Series.html#unordered_distinct/1","title":"Explorer.Series.unordered_distinct/1","type":"function"},{"doc":"Converts all characters to uppercase. Examples iex&gt; s = Explorer.Series . from_list ( [ &quot;abc&quot; , &quot;def&quot; , &quot;bcd&quot; ] ) iex&gt; Explorer.Series . upcase ( s ) # Explorer.Series &lt; Polars [ 3 ] string [ &quot;ABC&quot; , &quot;DEF&quot; , &quot;BCD&quot; ] &gt;","ref":"Explorer.Series.html#upcase/1","title":"Explorer.Series.upcase/1","type":"function"},{"doc":"Gets the variance of the series. Supported dtypes :integer :float Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . variance ( s ) 1.0 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . variance ( s ) 1.0 iex&gt; s = Explorer.Series . from_list ( [ ~N[2021-01-01 00:00:00] , ~N[1999-12-31 00:00:00] ] ) iex&gt; Explorer.Series . variance ( s ) ** (ArgumentError) Explorer.Series.variance/1 not implemented for dtype :datetime. Valid dtypes are [:integer, :float]","ref":"Explorer.Series.html#variance/1","title":"Explorer.Series.variance/1","type":"function"},{"doc":"Calculate the rolling max, given a window size and optional list of weights. Options :weights - An optional list of weights with the same length as the window that will be multiplied elementwise with the values in the window. Defaults to nil . :min_periods - The number of values in the window that should be non-nil before computing a result. If nil , it will be set equal to window size. Defaults to 1 . :center - Set the labels at the center of the window. Defaults to false . Examples iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . window_max ( s , 4 ) # Explorer.Series &lt; Polars [ 10 ] integer [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] &gt; iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . window_max ( s , 2 , weights : [ 1.0 , 2.0 ] ) # Explorer.Series &lt; Polars [ 10 ] float [ 1.0 , 4.0 , 6.0 , 8.0 , 10.0 , 12.0 , 14.0 , 16.0 , 18.0 , 20.0 ] &gt;","ref":"Explorer.Series.html#window_max/3","title":"Explorer.Series.window_max/3","type":"function"},{"doc":"Calculate the rolling mean, given a window size and optional list of weights. Options :weights - An optional list of weights with the same length as the window that will be multiplied elementwise with the values in the window. Defaults to nil . :min_periods - The number of values in the window that should be non-nil before computing a result. If nil , it will be set equal to window size. Defaults to 1 . :center - Set the labels at the center of the window. Defaults to false . Examples iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . window_mean ( s , 4 ) # Explorer.Series &lt; Polars [ 10 ] float [ 1.0 , 1.5 , 2.0 , 2.5 , 3.5 , 4.5 , 5.5 , 6.5 , 7.5 , 8.5 ] &gt; iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . window_mean ( s , 2 , weights : [ 1.0 , 2.0 ] ) # Explorer.Series &lt; Polars [ 10 ] float [ 1.0 , 2.5 , 4.0 , 5.5 , 7.0 , 8.5 , 10.0 , 11.5 , 13.0 , 14.5 ] &gt;","ref":"Explorer.Series.html#window_mean/3","title":"Explorer.Series.window_mean/3","type":"function"},{"doc":"Calculate the rolling min, given a window size and optional list of weights. Options :weights - An optional list of weights with the same length as the window that will be multiplied elementwise with the values in the window. Defaults to nil . :min_periods - The number of values in the window that should be non-nil before computing a result. If nil , it will be set equal to window size. Defaults to 1 . :center - Set the labels at the center of the window. Defaults to false . Examples iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . window_min ( s , 4 ) # Explorer.Series &lt; Polars [ 10 ] integer [ 1 , 1 , 1 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ] &gt; iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . window_min ( s , 2 , weights : [ 1.0 , 2.0 ] ) # Explorer.Series &lt; Polars [ 10 ] float [ 1.0 , 1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0 ] &gt;","ref":"Explorer.Series.html#window_min/3","title":"Explorer.Series.window_min/3","type":"function"},{"doc":"Calculate the rolling sum, given a window size and optional list of weights. Options :weights - An optional list of weights with the same length as the window that will be multiplied elementwise with the values in the window. Defaults to nil . :min_periods - The number of values in the window that should be non-nil before computing a result. If nil , it will be set equal to window size. Defaults to 1 . :center - Set the labels at the center of the window. Defaults to false . Examples iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . window_sum ( s , 4 ) # Explorer.Series &lt; Polars [ 10 ] integer [ 1 , 3 , 6 , 10 , 14 , 18 , 22 , 26 , 30 , 34 ] &gt; iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . window_sum ( s , 2 , weights : [ 1.0 , 2.0 ] ) # Explorer.Series &lt; Polars [ 10 ] float [ 1.0 , 5.0 , 8.0 , 11.0 , 14.0 , 17.0 , 20.0 , 23.0 , 26.0 , 29.0 ] &gt;","ref":"Explorer.Series.html#window_sum/3","title":"Explorer.Series.window_sum/3","type":"function"},{"doc":"","ref":"Explorer.Series.html#t:dtype/0","title":"Explorer.Series.dtype/0","type":"type"},{"doc":"","ref":"Explorer.Series.html#t:lazy_t/0","title":"Explorer.Series.lazy_t/0","type":"type"},{"doc":"","ref":"Explorer.Series.html#t:non_finite/0","title":"Explorer.Series.non_finite/0","type":"type"},{"doc":"","ref":"Explorer.Series.html#t:t/0","title":"Explorer.Series.t/0","type":"type"},{"doc":"TensorFrame is a representation of Explorer.DataFrame that is designed to work inside Nx's defn expressions. For example, imagine the following defn : defn add_columns ( tf ) do tf [ :a ] + tf [ :b ] end We can now pass a DataFrame as argument: iex&gt; add_columns ( Explorer.DataFrame . new ( a : [ 11 , 12 ] , b : [ 21 , 22 ] ) ) # Nx.Tensor &lt; s64 [ 2 ] [ 32 , 34 ] &gt; Passing an Explorer.DataFrame to a defn will automatically convert it to a TensorFrame. The TensorFrame will lazily build tensors out of the used dataframe fields. Stack and concatenating Due to the integration with Nx, you can also pass dataframes into Nx.stack/2 and Nx.concatenate and they will be automatically converted to tensors. This makes it easy to pass dataframes into neural networks and other computationally intensive algorithms: iex&gt; Nx . concatenate ( Explorer.DataFrame . new ( a : [ 11 , 12 ] , b : [ 21 , 22 ] ) ) # Nx.Tensor &lt; s64 [ 4 ] [ 11 , 12 , 21 , 22 ] &gt; iex&gt; Nx . stack ( Explorer.DataFrame . new ( a : [ 11 , 12 ] , b : [ 21 , 22 ] ) ) # Nx.Tensor &lt; s64 [ 2 ] [ 2 ] [ [ 11 , 12 ] , [ 21 , 22 ] ] &gt; iex&gt; Nx . stack ( Explorer.DataFrame . new ( a : [ 11 , 12 ] , b : [ 21 , 22 ] ) , axis : - 1 ) # Nx.Tensor &lt; s64 [ 2 ] [ 2 ] [ [ 11 , 21 ] , [ 12 , 22 ] ] &gt; Warning: returning TensorFrames It is not recommended to return a TensorFrame from a defn , as that would force all columns to be sent to the CPU/GPU and then copied back. Return only the columns that have been modified during the computation. For example, in the example above we used Nx to add two columns, if you want to put the result of the computation back into a DataFrame, you can use Explorer.DataFrame.put/4 , which also accepts tensors: iex&gt; df = Explorer.DataFrame . new ( a : [ 11 , 12 ] , b : [ 21 , 22 ] ) iex&gt; Explorer.DataFrame . put ( df , &quot;result&quot; , add_columns ( df ) ) # Explorer.DataFrame &lt; Polars [ 2 x 3 ] a integer [ 11 , 12 ] b integer [ 21 , 22 ] result integer [ 32 , 34 ] &gt; One benefit of using Explorer.DataFrame.put/4 is that it will preserve the type of the column if one already exists. Alternatively, use Explorer.Series.from_tensor/1 to explicitly convert a tensor back to a series. Supported dtypes The following dtypes can be converted to tensors: :integer :float :boolean :date :datetime See Explorer.Series.to_iovec/1 and Explorer.Series.to_tensor/1 to learn more about their internal representation.","ref":"Explorer.TensorFrame.html","title":"Explorer.TensorFrame","type":"module"},{"doc":"Pulls a tensor from the TensorFrame. This is equivalent to using the tf[name] to access a tensor. Examples Explorer.TensorFrame . pull ( tf , &quot;some_column&quot; )","ref":"Explorer.TensorFrame.html#pull/2","title":"Explorer.TensorFrame.pull/2","type":"function"},{"doc":"Puts a tensor in the TensorFrame. This function can be invoked from within defn . Examples Explorer.TensorFrame . put ( tf , &quot;result&quot; , some_tensor )","ref":"Explorer.TensorFrame.html#put/3","title":"Explorer.TensorFrame.put/3","type":"function"},{"doc":"","ref":"Explorer.TensorFrame.html#t:t/0","title":"Explorer.TensorFrame.t/0","type":"type"},{"doc":"The behaviour for Explorer backends and associated functions. Each backend is a module with DataFrame and Series submodules that match the respective behaviours for each. The default backend is read from the application environment. Currently, the only backend is an in-memory, eager one based on Polars . When alternatives are available, you can use them by configuring your runtime: # config/runtime.exs import Config config :explorer , default_backend : Lib.CustomBackend","ref":"Explorer.Backend.html","title":"Explorer.Backend","type":"module"},{"doc":"Gets the default backend for the current process.","ref":"Explorer.Backend.html#get/0","title":"Explorer.Backend.get/0","type":"function"},{"doc":"Sets the current process default backend to backend . The default backend is stored only in the process dictionary. This means if you start a separate process, such as Task , the default backend must be set on the new process too. Examples iex&gt; Explorer.Backend . put ( Lib.CustomBackend ) Explorer.PolarsBackend iex&gt; Explorer.Backend . get ( ) Lib.CustomBackend","ref":"Explorer.Backend.html#put/1","title":"Explorer.Backend.put/1","type":"function"},{"doc":"The behaviour for DataFrame backends.","ref":"Explorer.Backend.DataFrame.html","title":"Explorer.Backend.DataFrame","type":"behaviour"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:arrange_with/3","title":"Explorer.Backend.DataFrame.arrange_with/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:collect/1","title":"Explorer.Backend.DataFrame.collect/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:concat_columns/2","title":"Explorer.Backend.DataFrame.concat_columns/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:concat_rows/2","title":"Explorer.Backend.DataFrame.concat_rows/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:describe/2","title":"Explorer.Backend.DataFrame.describe/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:distinct/3","title":"Explorer.Backend.DataFrame.distinct/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:drop_nil/2","title":"Explorer.Backend.DataFrame.drop_nil/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:dummies/3","title":"Explorer.Backend.DataFrame.dummies/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:dump_csv/3","title":"Explorer.Backend.DataFrame.dump_csv/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:dump_ipc/2","title":"Explorer.Backend.DataFrame.dump_ipc/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:dump_ipc_stream/2","title":"Explorer.Backend.DataFrame.dump_ipc_stream/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:dump_ndjson/1","title":"Explorer.Backend.DataFrame.dump_ndjson/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:dump_parquet/2","title":"Explorer.Backend.DataFrame.dump_parquet/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:filter_with/3","title":"Explorer.Backend.DataFrame.filter_with/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:from_csv/12","title":"Explorer.Backend.DataFrame.from_csv/12","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:from_ipc/2","title":"Explorer.Backend.DataFrame.from_ipc/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:from_ipc_stream/2","title":"Explorer.Backend.DataFrame.from_ipc_stream/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:from_ndjson/3","title":"Explorer.Backend.DataFrame.from_ndjson/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:from_parquet/3","title":"Explorer.Backend.DataFrame.from_parquet/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:from_series/1","title":"Explorer.Backend.DataFrame.from_series/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:from_tabular/2","title":"Explorer.Backend.DataFrame.from_tabular/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:head/2","title":"Explorer.Backend.DataFrame.head/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:inspect/2","title":"Explorer.Backend.DataFrame.inspect/2","type":"callback"},{"doc":"Default inspect implementation for backends.","ref":"Explorer.Backend.DataFrame.html#inspect/5","title":"Explorer.Backend.DataFrame.inspect/5","type":"function"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:join/5","title":"Explorer.Backend.DataFrame.join/5","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:lazy/0","title":"Explorer.Backend.DataFrame.lazy/0","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:load_csv/12","title":"Explorer.Backend.DataFrame.load_csv/12","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:load_ipc/2","title":"Explorer.Backend.DataFrame.load_ipc/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:load_ipc_stream/2","title":"Explorer.Backend.DataFrame.load_ipc_stream/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:load_ndjson/3","title":"Explorer.Backend.DataFrame.load_ndjson/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:load_parquet/1","title":"Explorer.Backend.DataFrame.load_parquet/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:mask/2","title":"Explorer.Backend.DataFrame.mask/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:mutate_with/3","title":"Explorer.Backend.DataFrame.mutate_with/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:n_rows/1","title":"Explorer.Backend.DataFrame.n_rows/1","type":"callback"},{"doc":"Creates a new DataFrame for a given backend.","ref":"Explorer.Backend.DataFrame.html#new/3","title":"Explorer.Backend.DataFrame.new/3","type":"function"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:pivot_longer/6","title":"Explorer.Backend.DataFrame.pivot_longer/6","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:pivot_wider/5","title":"Explorer.Backend.DataFrame.pivot_wider/5","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:pull/2","title":"Explorer.Backend.DataFrame.pull/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:put/4","title":"Explorer.Backend.DataFrame.put/4","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:rename/3","title":"Explorer.Backend.DataFrame.rename/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:sample/5","title":"Explorer.Backend.DataFrame.sample/5","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:select/2","title":"Explorer.Backend.DataFrame.select/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:slice/2","title":"Explorer.Backend.DataFrame.slice/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:slice/3","title":"Explorer.Backend.DataFrame.slice/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:summarise_with/3","title":"Explorer.Backend.DataFrame.summarise_with/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:tail/2","title":"Explorer.Backend.DataFrame.tail/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:to_csv/4","title":"Explorer.Backend.DataFrame.to_csv/4","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:to_ipc/4","title":"Explorer.Backend.DataFrame.to_ipc/4","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:to_ipc_stream/3","title":"Explorer.Backend.DataFrame.to_ipc_stream/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:to_lazy/1","title":"Explorer.Backend.DataFrame.to_lazy/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:to_ndjson/2","title":"Explorer.Backend.DataFrame.to_ndjson/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:to_parquet/4","title":"Explorer.Backend.DataFrame.to_parquet/4","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:to_rows/2","title":"Explorer.Backend.DataFrame.to_rows/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:to_rows_stream/3","title":"Explorer.Backend.DataFrame.to_rows_stream/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:basic_types/0","title":"Explorer.Backend.DataFrame.basic_types/0","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:column_name/0","title":"Explorer.Backend.DataFrame.column_name/0","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:columns_for_io/0","title":"Explorer.Backend.DataFrame.columns_for_io/0","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:compression/0","title":"Explorer.Backend.DataFrame.compression/0","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:df/0","title":"Explorer.Backend.DataFrame.df/0","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:dtype/0","title":"Explorer.Backend.DataFrame.dtype/0","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:dtypes/0","title":"Explorer.Backend.DataFrame.dtypes/0","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:lazy_frame/0","title":"Explorer.Backend.DataFrame.lazy_frame/0","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:lazy_series/0","title":"Explorer.Backend.DataFrame.lazy_series/0","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:mutate_value/0","title":"Explorer.Backend.DataFrame.mutate_value/0","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:ok_result/0","title":"Explorer.Backend.DataFrame.ok_result/0","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:option/1","title":"Explorer.Backend.DataFrame.option/1","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:result/1","title":"Explorer.Backend.DataFrame.result/1","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:series/0","title":"Explorer.Backend.DataFrame.series/0","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:t/0","title":"Explorer.Backend.DataFrame.t/0","type":"type"},{"doc":"Represents a lazy dataframe for building query expressions. The LazyFrame is available inside filter_with , mutate_with , and similar. You cannot perform any operation on them except accessing its underlying series.","ref":"Explorer.Backend.LazyFrame.html","title":"Explorer.Backend.LazyFrame","type":"module"},{"doc":"","ref":"Explorer.Backend.LazyFrame.html#t:t/0","title":"Explorer.Backend.LazyFrame.t/0","type":"type"},{"doc":"This is an opaque implementation of a Series. It represents an operation with its arguments.","ref":"Explorer.Backend.LazySeries.html","title":"Explorer.Backend.LazySeries","type":"module"},{"doc":"","ref":"Explorer.Backend.LazySeries.html#t:t/0","title":"Explorer.Backend.LazySeries.t/0","type":"type"},{"doc":"The behaviour for series backends.","ref":"Explorer.Backend.Series.html","title":"Explorer.Backend.Series","type":"behaviour"},{"doc":"","ref":"Explorer.Backend.Series.html#c:acos/1","title":"Explorer.Backend.Series.acos/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:add/2","title":"Explorer.Backend.Series.add/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:all_equal/2","title":"Explorer.Backend.Series.all_equal/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:argsort/3","title":"Explorer.Backend.Series.argsort/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:asin/1","title":"Explorer.Backend.Series.asin/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:at/2","title":"Explorer.Backend.Series.at/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:at_every/2","title":"Explorer.Backend.Series.at_every/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:atan/1","title":"Explorer.Backend.Series.atan/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:binary_and/2","title":"Explorer.Backend.Series.binary_and/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:binary_in/2","title":"Explorer.Backend.Series.binary_in/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:binary_or/2","title":"Explorer.Backend.Series.binary_or/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:cast/2","title":"Explorer.Backend.Series.cast/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:categories/1","title":"Explorer.Backend.Series.categories/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:categorise/2","title":"Explorer.Backend.Series.categorise/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:ceil/1","title":"Explorer.Backend.Series.ceil/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:coalesce/2","title":"Explorer.Backend.Series.coalesce/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:concat/1","title":"Explorer.Backend.Series.concat/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:contains/2","title":"Explorer.Backend.Series.contains/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:cos/1","title":"Explorer.Backend.Series.cos/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:count/1","title":"Explorer.Backend.Series.count/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:cumulative_max/2","title":"Explorer.Backend.Series.cumulative_max/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:cumulative_min/2","title":"Explorer.Backend.Series.cumulative_min/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:cumulative_sum/2","title":"Explorer.Backend.Series.cumulative_sum/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:day_of_week/1","title":"Explorer.Backend.Series.day_of_week/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:distinct/1","title":"Explorer.Backend.Series.distinct/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:divide/2","title":"Explorer.Backend.Series.divide/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:downcase/1","title":"Explorer.Backend.Series.downcase/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:dtype/1","title":"Explorer.Backend.Series.dtype/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:equal/2","title":"Explorer.Backend.Series.equal/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:ewm_mean/5","title":"Explorer.Backend.Series.ewm_mean/5","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:exp/1","title":"Explorer.Backend.Series.exp/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:fill_missing_with_strategy/2","title":"Explorer.Backend.Series.fill_missing_with_strategy/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:fill_missing_with_value/2","title":"Explorer.Backend.Series.fill_missing_with_value/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:first/1","title":"Explorer.Backend.Series.first/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:floor/1","title":"Explorer.Backend.Series.floor/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:format/1","title":"Explorer.Backend.Series.format/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:frequencies/1","title":"Explorer.Backend.Series.frequencies/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:from_binary/2","title":"Explorer.Backend.Series.from_binary/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:from_list/2","title":"Explorer.Backend.Series.from_list/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:greater/2","title":"Explorer.Backend.Series.greater/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:greater_equal/2","title":"Explorer.Backend.Series.greater_equal/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:head/2","title":"Explorer.Backend.Series.head/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:inspect/2","title":"Explorer.Backend.Series.inspect/2","type":"callback"},{"doc":"Default inspect implementation for backends.","ref":"Explorer.Backend.Series.html#inspect/5","title":"Explorer.Backend.Series.inspect/5","type":"function"},{"doc":"","ref":"Explorer.Backend.Series.html#c:iotype/1","title":"Explorer.Backend.Series.iotype/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:is_finite/1","title":"Explorer.Backend.Series.is_finite/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:is_infinite/1","title":"Explorer.Backend.Series.is_infinite/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:is_nan/1","title":"Explorer.Backend.Series.is_nan/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:is_nil/1","title":"Explorer.Backend.Series.is_nil/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:is_not_nil/1","title":"Explorer.Backend.Series.is_not_nil/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:last/1","title":"Explorer.Backend.Series.last/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:less/2","title":"Explorer.Backend.Series.less/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:less_equal/2","title":"Explorer.Backend.Series.less_equal/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:log/1","title":"Explorer.Backend.Series.log/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:log/2","title":"Explorer.Backend.Series.log/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:mask/2","title":"Explorer.Backend.Series.mask/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:max/1","title":"Explorer.Backend.Series.max/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:mean/1","title":"Explorer.Backend.Series.mean/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:median/1","title":"Explorer.Backend.Series.median/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:min/1","title":"Explorer.Backend.Series.min/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:multiply/2","title":"Explorer.Backend.Series.multiply/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:n_distinct/1","title":"Explorer.Backend.Series.n_distinct/1","type":"callback"},{"doc":"Create a new Series .","ref":"Explorer.Backend.Series.html#new/2","title":"Explorer.Backend.Series.new/2","type":"function"},{"doc":"","ref":"Explorer.Backend.Series.html#c:nil_count/1","title":"Explorer.Backend.Series.nil_count/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:not_equal/2","title":"Explorer.Backend.Series.not_equal/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:peaks/2","title":"Explorer.Backend.Series.peaks/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:pow/2","title":"Explorer.Backend.Series.pow/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:quantile/2","title":"Explorer.Backend.Series.quantile/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:quotient/2","title":"Explorer.Backend.Series.quotient/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:remainder/2","title":"Explorer.Backend.Series.remainder/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:reverse/1","title":"Explorer.Backend.Series.reverse/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:round/2","title":"Explorer.Backend.Series.round/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:sample/5","title":"Explorer.Backend.Series.sample/5","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:select/3","title":"Explorer.Backend.Series.select/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:shift/3","title":"Explorer.Backend.Series.shift/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:sin/1","title":"Explorer.Backend.Series.sin/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:size/1","title":"Explorer.Backend.Series.size/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:slice/2","title":"Explorer.Backend.Series.slice/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:slice/3","title":"Explorer.Backend.Series.slice/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:sort/3","title":"Explorer.Backend.Series.sort/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:standard_deviation/1","title":"Explorer.Backend.Series.standard_deviation/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:subtract/2","title":"Explorer.Backend.Series.subtract/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:sum/1","title":"Explorer.Backend.Series.sum/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:tail/2","title":"Explorer.Backend.Series.tail/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:tan/1","title":"Explorer.Backend.Series.tan/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:to_date/1","title":"Explorer.Backend.Series.to_date/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:to_iovec/1","title":"Explorer.Backend.Series.to_iovec/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:to_list/1","title":"Explorer.Backend.Series.to_list/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:to_time/1","title":"Explorer.Backend.Series.to_time/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:transform/2","title":"Explorer.Backend.Series.transform/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:trim/1","title":"Explorer.Backend.Series.trim/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:trim_leading/1","title":"Explorer.Backend.Series.trim_leading/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:trim_trailing/1","title":"Explorer.Backend.Series.trim_trailing/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:unary_not/1","title":"Explorer.Backend.Series.unary_not/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:unordered_distinct/1","title":"Explorer.Backend.Series.unordered_distinct/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:upcase/1","title":"Explorer.Backend.Series.upcase/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:variance/1","title":"Explorer.Backend.Series.variance/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:window_max/5","title":"Explorer.Backend.Series.window_max/5","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:window_mean/5","title":"Explorer.Backend.Series.window_mean/5","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:window_min/5","title":"Explorer.Backend.Series.window_min/5","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:window_sum/5","title":"Explorer.Backend.Series.window_sum/5","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#t:df/0","title":"Explorer.Backend.Series.df/0","type":"type"},{"doc":"","ref":"Explorer.Backend.Series.html#t:dtype/0","title":"Explorer.Backend.Series.dtype/0","type":"type"},{"doc":"","ref":"Explorer.Backend.Series.html#t:lazy_s/0","title":"Explorer.Backend.Series.lazy_s/0","type":"type"},{"doc":"","ref":"Explorer.Backend.Series.html#t:non_finite/0","title":"Explorer.Backend.Series.non_finite/0","type":"type"},{"doc":"","ref":"Explorer.Backend.Series.html#t:option/1","title":"Explorer.Backend.Series.option/1","type":"type"},{"doc":"","ref":"Explorer.Backend.Series.html#t:s/0","title":"Explorer.Backend.Series.s/0","type":"type"},{"doc":"","ref":"Explorer.Backend.Series.html#t:t/0","title":"Explorer.Backend.Series.t/0","type":"type"},{"doc":"","ref":"Explorer.Backend.Series.html#t:valid_types/0","title":"Explorer.Backend.Series.valid_types/0","type":"type"},{"doc":"The Explorer backend for Polars.","ref":"Explorer.PolarsBackend.html","title":"Explorer.PolarsBackend","type":"module"},{"doc":"Mix . install ( [ { :explorer , &quot;~&gt; 0.5.0&quot; } , { :kino , &quot;~&gt; 0.8.0&quot; } ] )","ref":"exploring_explorer.html","title":"Ten Minutes to Explorer","type":"extras"},{"doc":"Explorer is a dataframe library for Elixir. A dataframe is a common data structure used in data analysis. It is a two-dimensional table composed of columns and rows similar to a SQL table or a spreadsheet. Explorer's aim is to provide a simple and powerful API for manipulating dataframes. It takes influences mainly from the tidyverse , but if you've used other dataframe libraries like pandas you shouldn't have too much trouble working with Explorer. This document is meant to give you a crash course in using Explorer. More in-depth documentation can be found in the relevant sections of the docs. We strongly recommend you run this livebook locally so you can see the outputs and play with the inputs!","ref":"exploring_explorer.html#introduction","title":"Ten Minutes to Explorer - Introduction","type":"extras"},{"doc":"Data can be read from delimited files (like CSV), NDJSON, Parquet, and the Arrow IPC (feather) format. You can also load in data from a map or keyword list of columns with Explorer.DataFrame.new/1 . For CSV, your 'usual suspects' of options are available: delimiter - A single character used to separate fields within a record. (default: &quot;,&quot; ) dtypes - A keyword list of [column_name: dtype] . If a type is not specified for a column, it is imputed from the first 1000 rows. (default: [] ) header - Does the file have a header of column names as the first row or not? (default: true ) max_rows - Maximum number of lines to read. (default: nil ) null_character - The string that should be interpreted as a nil value. (default: &quot;NA&quot; ) skip_rows - The number of lines to skip at the beginning of the file. (default: 0 ) columns - A list of column names to keep. If present, only these columns are read into the dataframe. (default: nil ) Explorer also has multiple example datasets built in, which you can load from the Explorer.Datasets module like so: df = Explorer.Datasets . fossil_fuels ( ) You'll notice that the output looks slightly different than many dataframe libraries. Explorer takes inspiration on this front from glimpse in R. A benefit to this approach is that you will rarely need to elide columns. If you'd like to see a table with your data, we've got you covered there too. Explorer.DataFrame . table ( df ) Writing files is very similar to reading them. The options are a little more limited: header - Should the column names be written as the first line of the file? (default: true ) delimiter - A single character used to separate fields within a record. (default: &quot;,&quot; ) First, let's add some useful aliases: alias Explorer.DataFrame alias Explorer.Series And then write to a file of your choosing: input = Kino.Input . text ( &quot;Filename&quot; ) filename = Kino.Input . read ( input ) DataFrame . to_csv ( df , filename )","ref":"exploring_explorer.html#reading-and-writing-data","title":"Ten Minutes to Explorer - Reading and writing data","type":"extras"},{"doc":"Explorer , like Polars , works up from the concept of a Series . In many ways, you can think of a dataframe as a row-aligned map of Series . These are like vectors in R or series in Pandas. For simplicity, Explorer uses the following Series dtypes : :float - 64-bit floating point number :integer - 64-bit signed integer :boolean - Boolean :string - UTF-8 encoded binary :date - Date type that unwraps to Elixir.Date :datetime - DateTime type that unwraps to Elixir.NaiveDateTime Series can be constructed from Elixir basic types. For example: s1 = Series . from_list ( [ 1 , 2 , 3 ] ) s2 = Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) s3 = Series . from_list ( [ ~D[2011-01-01] , ~D[1965-01-21] ] ) You'll notice that the dtype and size of the Series are at the top of the printed value. You can get those programmatically as well. Series . dtype ( s3 ) Series . size ( s3 ) And the printed values max out at 50: 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Series . from_list ( ) Series are also nullable. s = Series . from_list ( [ 1.0 , 2.0 , nil , nil , 5.0 ] ) And you can fill in those missing values using one of the following strategies: :forward - replace nil with the previous value :backward - replace nil with the next value :max - replace nil with the series maximum :min - replace nil with the series minimum :mean - replace nil with the series mean Series . fill_missing ( s , :forward ) In the case of mixed numeric types (i.e. integers and floats), Series will downcast to a float: Series . from_list ( [ 1 , 2.0 ] ) In all other cases, Series must all be of the same dtype or else you'll get an ArgumentError . Series . from_list ( [ 1 , 2 , 3 , &quot;a&quot; ] ) One of the goals of Explorer is useful error messages . If you look at the error above, you get: Cannot make a series from mismatched types. Type of &quot;a&quot; does not match inferred dtype integer. Hopefully this makes abundantly clear what's going on. Series also implements the Access protocol. You can slice and dice in many ways: s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Series . from_list ( ) s [ 1 ] s [ - 1 ] s [ 0 .. 4 ] s [ [ 0 , 4 , 4 ] ] And of course, you can convert back to an Elixir list. Series . to_list ( s ) Explorer supports comparisons. s = 1 .. 11 |&gt; Enum . to_list ( ) |&gt; Series . from_list ( ) s1 = 11 .. 1 |&gt; Enum . to_list ( ) |&gt; Series . from_list ( ) Series . equal ( s , s1 ) Series . equal ( s , 5 ) Series . not_equal ( s , 10 ) Series . greater_equal ( s , 4 ) And arithmetic. Series . add ( s , s1 ) Series . subtract ( s , 4 ) Series . multiply ( s , s1 ) Remember those helpful errors? We've tried to add those throughout. So if you try to do arithmetic with mismatching dtypes: s = Series . from_list ( [ 1 , 2 , 3 ] ) s1 = Series . from_list ( [ 1.0 , 2.0 , 3.0 ] ) Series . add ( s , s1 ) Just kidding! Integers and floats will downcast to floats. Let's try again: s = Series . from_list ( [ 1 , 2 , 3 ] ) s1 = Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) Series . add ( s , s1 ) You can flip them around. s = Series . from_list ( [ 1 , 2 , 3 , 4 ] ) Series . reverse ( s ) And sort. 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Enum . shuffle ( ) |&gt; Series . from_list ( ) |&gt; Series . sort ( ) Or argsort. s = 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Enum . shuffle ( ) |&gt; Series . from_list ( ) ids = Series . argsort ( s ) |&gt; Series . to_list ( ) Which you can pass to Explorer.Series.slice/2 if you want the sorted values. Series . slice ( s , ids ) You can calculate cumulative values. s = 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Series . from_list ( ) Series . cumulative_sum ( s ) Or rolling ones. Series . window_sum ( s , 4 ) You can count and list unique values. s = Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;b&quot; , &quot;c&quot; , &quot;c&quot; , &quot;c&quot; ] ) Series . distinct ( s ) Series . n_distinct ( s ) And you can even get a dataframe showing the frequencies for each distinct value. Series . frequencies ( s )","ref":"exploring_explorer.html#working-with-series","title":"Ten Minutes to Explorer - Working with Series","type":"extras"},{"doc":"A DataFrame is really just a collection of Series of the same size. Which is why you can create a DataFrame from a Keyword list. DataFrame . new ( a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) Similarly to Series , the Inspect implementation prints some info at the top and to the left. At the top we see the shape of the dataframe (rows and columns) and then for each column we see the name, dtype, and first five values. We can see a bit more from that built-in dataset we loaded in earlier. df You will also see grouping information there, but we'll get to that later. You can get the info yourself directly: DataFrame . names ( df ) DataFrame . dtypes ( df ) DataFrame . shape ( df ) { DataFrame . n_rows ( df ) , DataFrame . n_columns ( df ) } We can grab the head. DataFrame . head ( df ) Or the tail. Let's get a few more values from the tail. DataFrame . tail ( df , 10 ) Verbs and macros In Explorer , like in dplyr , we have five main verbs to work with dataframes: select filter mutate arrange summarise We are going to explore then in this notebook, but first we need to &quot;require&quot; the Explorer.DataFrame module in order to load the macros needed for these verbs. I want to take the opportunity to create a shorter alias for the DataFrame module, called DF : require DataFrame , as : DF From now on we are using the shorter version, DF , to refer to the required Explorer.DataFrame module. Select Let's jump right into it. We can select columns pretty simply. DF . select ( df , [ &quot;year&quot; , &quot;country&quot; ] ) But Elixir gives us some superpowers. In R there's tidy-select . I don't think we need that in Elixir. Anywhere in Explorer where you need to pass a list of column names, you can also execute a filtering callback on the column names. It's just an anonymous function passed to df |&gt; DataFrame.names() |&gt; Enum.filter(callback_here) . DF . select ( df , &amp; String . ends_with? ( &amp;1 , &quot;fuel&quot; ) ) Want all but some columns? discard/2 performs the opposite of select/2 . DF . discard ( df , &amp; String . ends_with? ( &amp;1 , &quot;fuel&quot; ) ) Filter The next verb we'll look at is filter . This is implemented using a macro, so it's possible to use expressions like you would if comparing variables in Elixir: DF . filter ( df , country == &quot;BRAZIL&quot; ) Using complex filters is also possible: DF . filter ( df , country == &quot;ALGERIA&quot; and year &gt; 2012 ) You can also write the same filter without the macro, by using the callback version function which is filter_with/2 : DF . filter_with ( df , fn ldf -&gt; ldf [ &quot;country&quot; ] |&gt; Series . equal ( &quot;ALGERIA&quot; ) |&gt; Series . and ( Series . greater ( ldf [ &quot;year&quot; ] , 2012 ) ) end ) By the way, all the Explorer.DataFrame macros have a correspondent function that accepts a callback. In fact, our macros are implemented using those functions. The filter_with/2 function is going to use a virtual representation of the dataframe that we call a &quot;lazy frame&quot;. With lazy frames you can´t access the series contents, but every operation will be optimized and run only once. Remember those helpful error messages? DF . filter ( df , cuontry == &quot;BRAZIL&quot; ) Mutate A common task in data analysis is to add columns or change existing ones. Mutate is a handy verb. DF . mutate ( df , new_column : solid_fuel + cement ) Did you catch that? You can pass in new columns as keyword arguments. It also works to transform existing columns. DF . mutate ( df , gas_fuel : Series . cast ( gas_fuel , :float ) , gas_and_liquid_fuel : gas_fuel + liquid_fuel ) DataFrame.mutate/2 is flexible though. You may not always want to use keyword arguments. Given that column names are String.t() , it may make more sense to use a map. DF . mutate ( df , %{ &quot;gas_fuel&quot; =&gt; gas_fuel - 10 } ) DF.transmute/2 , which is DF.mutate/2 that only retains the specified columns, is forthcoming. Arrange Sorting the dataframe is pretty straightforward. DF . arrange ( df , year ) But it comes with some tricks up its sleeve. DF . arrange ( df , asc : total , desc : year ) As the examples show, arrange/2 is a macro, and therefore you can use some functions to arrange your dataframe: DF . arrange ( df , asc : Series . window_sum ( total , 2 ) ) Sort operations happen left to right. And keyword list args permit specifying the direction. Distinct Okay, as expected here too. Very straightforward. DF . distinct ( df , [ &quot;year&quot; , &quot;country&quot; ] ) You can specify whether to keep the other columns as well, so the first row of each distinct value is kept: DF . distinct ( df , [ &quot;country&quot; ] , keep_all : true ) Rename Rename can take either a list of new names or a callback that is passed to Enum.map/2 against the names. You can also use a map or keyword args to rename specific columns. DF . rename ( df , year : &quot;year_test&quot; ) DF . rename_with ( df , &amp; ( &amp;1 &lt;&gt; &quot;_test&quot; ) ) Dummies This is fun! We can get dummy variables for unique values. DF . dummies ( df , [ &quot;year&quot; ] ) DF . dummies ( df , [ &quot;country&quot; ] ) Sampling Random samples can give us a percent or a specific number of samples, with or without replacement, and the function is seedable. DF . sample ( df , 10 ) DF . sample ( df , 0.4 ) Trying for those helpful error messages again. DF . sample ( df , 10000 ) DF . sample ( df , 10000 , replacement : true ) Pull and slice Slicing and dicing can be done with the Access protocol or with explicit pull/slice/take functions. df [ &quot;year&quot; ] DF . pull ( df , &quot;year&quot; ) df [ [ &quot;year&quot; , &quot;country&quot; ] ] DF . slice ( df , [ 1 , 20 , 50 ] ) Negative offsets work for slice! DF . slice ( df , - 10 , 5 ) DF . slice ( df , 10 , 5 ) Slice also works with ranges: DF . slice ( df , 12 .. 42 ) Pivot We can pivot_longer/3 and pivot_wider/4 . These are inspired by tidyr . There are some shortcomings in pivot_wider/4 related to polars . The values_from column must be a numeric type. DF . pivot_longer ( df , [ &quot;year&quot; , &quot;country&quot; ] , value_columns : &amp; String . ends_with? ( &amp;1 , &quot;fuel&quot; ) ) DF . pivot_wider ( df , &quot;country&quot; , &quot;total&quot; , id_columns : [ &quot;year&quot; ] ) Let's make those names look nicer! tidy_names = fn name -&gt; name |&gt; String . downcase ( ) |&gt; String . replace ( ~r/ \\s / , &quot; &quot; ) |&gt; String . replace ( ~r/[^A-Za-z \\s ]/ , &quot;&quot; ) |&gt; String . replace ( &quot; &quot; , &quot;_&quot; ) end df |&gt; DF . pivot_wider ( &quot;country&quot; , &quot;total&quot; , id_columns : [ &quot;year&quot; ] ) |&gt; DF . rename_with ( tidy_names ) Joins Joining is fast and easy. You can specify the columns to join on and how to join. Polars even supports cartesian (cross) joins, so Explorer does too. df1 = DF . select ( df , [ &quot;year&quot; , &quot;country&quot; , &quot;total&quot; ] ) df2 = DF . select ( df , [ &quot;year&quot; , &quot;country&quot; , &quot;cement&quot; ] ) DF . join ( df1 , df2 ) df3 = df |&gt; DF . select ( [ &quot;year&quot; , &quot;cement&quot; ] ) |&gt; DF . slice ( 0 , 500 ) DF . join ( df1 , df3 , how : :left ) Grouping Explorer supports groupby operations. They're limited based on what's possible in Polars, but they do most of what you need to do. grouped = DF . group_by ( df , [ &quot;country&quot; ] ) Notice that the Inspect call now shows groups as well as rows and columns . You can, of course, get them explicitly. DF . groups ( grouped ) And you can ungroup explicitly. DF . ungroup ( grouped ) But what we care about the most is aggregating! Let's see which country has the max per_capita value. grouped |&gt; DF . summarise ( max_per_capita : max ( per_capita ) ) |&gt; DF . arrange ( desc : max_per_capita ) Qatar it is. You may noticed that we are using max/1 inside the summarise macro. This is possible because we expose all functions from the Series module. You can use the following aggregations inside summarise: min/1 - Take the minimum value within the group. See Explorer.Series.min/1 . max/1 - Take the maximum value within the group. See Explorer.Series.max/1 . sum/1 - Take the sum of the series within the group. See Explorer.Series.sum/1 . mean/1 - Take the mean of the series within the group. See Explorer.Series.mean/1 . median/1 - Take the median of the series within the group. See Explorer.Series.median/1 . first/1 - Take the first value within the group. See Explorer.Series.first/1 . last/1 - Take the last value within the group. See Explorer.Series.last/1 . count/1 - Count the number of rows per group. n_unique/1 - Count the number of unique rows per group. The API is similar to mutate : you can use keyword args or a map and specify aggregations to use. DF . summarise ( grouped , min_per_capita : min ( per_capita ) , min_total : min ( total ) ) Speaking of mutate , it's 'group-aware'. As are arrange , distinct , and n_rows . DF . mutate ( grouped , total_window_sum : window_sum ( total , 3 ) , rows_in_group : count ( country ) ) It's also possible to use aggregations inside other functions: grouped |&gt; DF . summarise ( greater_than_9 : greater ( max ( per_capita ) , 9.0 ) , per_capita_max : max ( per_capita ) ) |&gt; DataFrame . arrange ( desc : per_capita_max ) That's it! And not. This is certainly not exhaustive, but I hope it gives you a good idea of what can be done and what the 'flavour' of the API is like. I'd love contributions and issues raised where you find them!","ref":"exploring_explorer.html#working-with-dataframes","title":"Ten Minutes to Explorer - Working with DataFrames","type":"extras"},{"doc":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","ref":"changelog.html","title":"Changelog","type":"extras"},{"doc":"","ref":"changelog.html#unreleased","title":"Changelog - Unreleased","type":"extras"},{"doc":"Added Add the following functions to the Explorer.Series module: log/1 , log/2 and exp/1 . They compute the logarithm and exponential of a series. Fixed Allow Explorer.Series.select/3 to receive series of size 1 for both the on_true and on_false arguments. Fix the encoding of special float values that may return from some series functions. This is going to encode the atoms for NaN and infinity values.","ref":"changelog.html#v0-5-6-2023-03-24","title":"Changelog - v0.5.6 - 2023-03-24","type":"extras"},{"doc":"Added Add support for multiple value columns in pivot wider. The resultant dataframe that is created from this type of pivoting is going to have columns with the names prefixed by the original value column, followed by an underscore and the name of the variable. Add Explorer.Series.ewm_mean/2 for calculating exponentially weighted moving average. Changed Change the Explorer.Backend.DataFrame 's pivot_wider callback to work with multiple columns instead of only one. Change the Explorer.Backend.DataFrame 's window_* callbacks to work with variables instead of keyword args. This is needed to make explicit when a backend is not implementing an option. Change the Explorer.Backend.DataFrame 's describe callback and remove the need for an &quot;out df&quot;, since we won't have a lazy version of that funcion. This shouldn't affect the API, but we had an update in Polars. It is now using v0.27.2 . For further details, see: Rust Polars 0.27.0 . Fixed Provide hints when converting string/binary series to tensors. Add libatomic as a link to the generated NIF. This is needed to fix the load of the Explorer NIF when running on ARM 32 bits machines like the Pi 3. See the original issue","ref":"changelog.html#v0-5-5-2023-03-13","title":"Changelog - v0.5.5 - 2023-03-13","type":"extras"},{"doc":"Fixed Fix missing &quot;README.md&quot; file in the list of package files. Our readme is now required in compilation, because it contains the moduledoc for the main Explorer module.","ref":"changelog.html#v0-5-4-2023-03-09","title":"Changelog - v0.5.4 - 2023-03-09","type":"extras"},{"doc":"Added Add the Explorer.Series.format/1 function that concatenates multiple series together, always returning a string series. With the addition of format/1 , we also have a new operator for string concatenation inside Explorer.Query . It is the &lt;&gt; operator, that is similar to what the Kernel.&lt;&gt;/2 operator does, but instead of concatenating strings, it concatenates two series, returning a string series - it is using format/1 underneath. Add support for slicing by series in dataframes and other series. Add support for 2D tensors in Explorer.DataFrame.new/2 . Fixed Fix Explorer.DataFrame.new/2 to respect the selected dtype when an entire series is nil. Improve error message for mismatched dtypes in series operations. Fix lazy series operations of binary series and binary values. This is going to wrap binary values in the correct dtype, in order to pass down to Polars. Fix two bugs in Explorer.DataFrame.pivot_wider/3 : nil values in the series that is used for new column names is now correctly creating a nil column. We also fixed the problem of a duplicated column created after pivoting, and possibly conflicting with an existing ID column. We add a suffix for these columns.","ref":"changelog.html#v0-5-3-2023-03-08","title":"Changelog - v0.5.3 - 2023-03-08","type":"extras"},{"doc":"Added Add across and comprehensions to Explorer.Query . These features allow a more flexible and elegant way to work with multiple columns at once. Example: iris = Explorer.Datasets . iris ( ) Explorer.DataFrame . mutate ( iris , for col &lt;- across ( [ &quot;sepal_width&quot; , &quot;sepal_length&quot; , &quot;petal_length&quot; , &quot;petal_width&quot; ] ) do { col . name , ( col - mean ( col ) ) / variance ( col ) } end ) See the Explorer.Query documentation for further details. Add support for regexes to select columns of a dataframe. Example: df = Explorer.Datasets . wine ( ) df [ ~r/(class|hue)/ ] Add the :max_rows and :columns options to Explorer.DataFrame.from_parquet/2 . This mirrors the from_csv/2 function. Allow Explorer.Series functions that accept floats to work with :nan , :infinity and :neg_infinity values. Add Explorer.DataFrame.shuffle/2 and Explorer.Series.shuffle/2 . Add support for a list of filters in Explorer.DataFrame.filter/2 . These filters are joined as and expressions. Fixed Add is_integer/1 guard to Explorer.Series.shift/2 . Raise if series sizes do not match for binary operations. Changed Rename the option :replacement to :replace for Explorer.DataFrame.sample/3 and Explorer.Series.sample/3 . Change the default behaviour of sampling to not shuffle by default. A new option named :shuffle was added to control that.","ref":"changelog.html#v0-5-2-2023-02-28","title":"Changelog - v0.5.2 - 2023-02-28","type":"extras"},{"doc":"Added Add boolean dtype to Series.in/2 . Add binary dtype to Series.in/2 . Add Series.day_of_week/1 . Allow Series.fill_missing/2 to: receive :infinity and :neg_infinity values. receive date and datetime values. receive binary values. Add support for time dtype. Add version of Series.pow/2 that accepts series on both sides. Allow Series.from_list/2 to receive :nan , :infinity and :neg_infinity atoms. Add Series.to_date/1 and Series.to_time/1 for datetime series. Allow casting of string series to category. Accept tensors when creating a new dataframe. Add compatibility with Nx v0.5. Add support for Nx's serialize and deserialize. Add the following function implementations for the Polars' Lazy dataframe backend: arrange_with concat_columns concat_rows distinct drop_nil filter_with join mutate_with pivot_longer rename summarise_with to_parquet Only summarise_with supports groups for this version. Changed Require version of Rustler to be ~&gt; 0.27.0 , which mirrors the NIF requirement. Fixed Casting to an unknown dtype returns a better error message.","ref":"changelog.html#v0-5-1-2023-02-17","title":"Changelog - v0.5.1 - 2023-02-17","type":"extras"},{"doc":"Added Add DataFrame.describe/2 to gather some statistics from a dataframe. Add Series.nil_count/1 to count nil values. Add Series.in/2 to check if a given value is inside a series. Add Series float predicates: is_finite/1 , is_infinite/1 and is_nan/1 . Add Series string functions: contains/2 , trim/1 , trim_leading/1 , trim_trailing/1 , upcase/1 and downcase/1 . Enable slicing of lazy frames ( LazyFrame ). Add IO operations &quot;from/load&quot; to the lazy frame implementation. Add support for the :lazy option in the DataFrame.new/2 function. Add Series float rounding methods: round/2 , floor/1 and ceil/1 . Add support for precompiling to Linux running on RISCV CPUs. Add support for precompiling to Linux - with musl - running on AARCH64 computers. Allow DataFrame.new/1 to receive the :dtypes option. Accept :nan as an option for Series.fill_missing/2 with float series. Add basic support for the categorical dtype - the :category dtype. Add Series.categories/1 to return categories from a categorical series. Add Series.categorise/2 to categorise a series of integers using predefined categories. Add Series.replace/2 to replace the contents of a series. Support selecting columns with unusual names (like with spaces) inside Explorer.Query with col/1 . The usage is like this: Explorer.DataFrame . filter ( df , col ( &quot;my col&quot; ) &gt; 42 ) Fixed Fix DataFrame.mutate/2 using a boolean scalar value. Stop leaking UInt32 series to Elixir. Cast numeric columns to our supported dtypes after IO read. This fix is only applied for the eager implementation for now. Changed Rename Series.bintype/1 to Series.iotype/1 .","ref":"changelog.html#v0-5-0-2023-01-12","title":"Changelog - v0.5.0 - 2023-01-12","type":"extras"},{"doc":"Added Add Series.quotient/2 and Series.remainder/2 to work with integer division. Add Series.iotype/1 to return the underlying representation type. Allow series on both sides of binary operations, like: add(series, 1) and add(1, series) . Allow comparison, concat and coalesce operations on &quot;(series, lazy series)&quot;. Add lazy version of Series.sample/3 and Series.size/1 . Add support for Arrow IPC Stream files. Add Explorer.Query and the macros that allow a simplified query API. This is a huge improvement to some of the main functions, and allow refering to columns as they were variables. Before this change we would need to write a filter like this: Explorer.DataFrame . filter_with ( df , &amp; Explorer.Series . greater ( &amp;1 [ &quot;col1&quot; ] , 42 ) ) But now it's also possible to write this operation like this: Explorer.DataFrame . filter ( df , col1 &gt; 42 ) This operation is going to use filter_with/2 underneath, which means that is going to use lazy series and compute the results at once. Notice that is mandatory to &quot;require&quot; the DataFrame module, since these operations are implemented as macros. The following new macros were added: filter/2 mutate/2 summarise/2 arrange/2 They substitute older versions that did not accept the new query syntax. Add DataFrame.put/3 to enable adding or replacing columns in a eager manner. This works similar to the previous version of mutate/2 . Add Series.select/3 operation that enables selecting a value from two series based on a predicate. Add &quot;dump&quot; and &quot;load&quot; functions to IO operations. They are useful to load or dump dataframes from/to memory. Add Series.to_iovec/2 and Series.to_binary/1 . They return the underlying representation of series as binary. The first one returns a list of binaries, possibly with one element if the series is contiguous in memory. The second one returns a single binary representing the series. Add Series.shift/2 that shifts the series by an offset with nil values. Rename Series.fetch!/2 and Series.take_every/2 to Series.at/2 and Series.at_every/2 . Add DataFrame.discard/2 to drop columns. This is the opposite of select/2 . Implement Nx.LazyContainer for Explorer.DataFrame and Explorer.Series so data can be passed into Nx. Add Series.not/1 that negates values in a boolean series. Add the :binary dtype for Series. This enables the usage of arbitrary binaries. Changed Change DataFrame's to_* functions to return only :ok . Change series inspect to resamble the dataframe inspect with the backend name. Rename Series.var/1 to Series.variance/1 Rename Series.std/1 to Series.standard_deviation/1 Rename Series.count/2 to Series.frequencies/1 and add a new Series.count/1 that returns the size of an &quot;eager&quot; series, or the count of members in a group for a lazy series. In case there is no groups, it calculates the size of the dataframe. Change the option to control direction in Series.sort/2 and Series.argsort/2 . Instead of a boolean, now we have a new option called :direction that accepts :asc or :desc . Fixed Fix the following DataFrame functions to work with groups: filter_with/2 head/2 tail/2 slice/2 slice/3 pivot_longer/3 pivot_wider/4 concat_rows/1 concat_columns/1 Improve the documentation of functions that behave differently with groups. Fix arrange_with/2 to use &quot;group by&quot; stable, making results more predictable. Add nil as a possible return value of aggregations. Fix the behaviour of Series.sort/2 and Series.argsort/2 to add nils at the front when direction is descending, or at the back when the direction is ascending. This also adds an option to control this behaviour. Removed Remove support for NDJSON read and write for ARM 32 bits targets. This is due to a limitation of a dependency of Polars.","ref":"changelog.html#v0-4-0-2022-11-29","title":"Changelog - v0.4.0 - 2022-11-29","type":"extras"},{"doc":"Fixed Define multiply inside *_with operations. Fix column types in several operations, such as n_distinct .","ref":"changelog.html#v0-3-1-2022-09-09","title":"Changelog - v0.3.1 - 2022-09-09","type":"extras"},{"doc":"Added Add DataFrame.concat_columns/1 and DataFrame.concat_columns/2 for horizontally stacking dataframes. Add compression as an option to write parquet files. Add count metadata to DataFrame table reader. Add DataFrame.filter_with/2 , DataFrame.summarise_with/2 , DataFrame.mutate_with/2 and DataFrame.arrange_with/2 . They all accept a DataFrame and a function, and they all work with a new concept called &quot;lazy series&quot;. Lazy Series is an opaque representation of a series that can be used to perform complex operations without pulling data from the series. This is faster than using masks. There is no big difference from the API perspective compared to the functions that were accepting callbacks before (eg. filter/2 and the new filter_with/2 ), with the exception being DataFrame.summarise_with/2 that now accepts a lot more operations. Changed Bump version requirement of the table dependency to ~&gt; 0.1.2 , and raise for non-tabular values. Normalize how columns are handled. This changes some functions to accept one column or a list of columns, ranges, indexes and callbacks selecting columns. Rename DataFrame.filter/2 to DataFrame.mask/2 . Rename Series.filter/2 to Series.mask/2 . Rename take/2 from both Series and DataFrame to slice/2 . slice/2 now they accept ranges as well. Raise an error if DataFrame.pivot_wider/4 has float columns as IDs. This is because we can´t properly compare floats. Change DataFrame.distinct/2 to accept columns as argument instead of receiving it as option. Fixed Ensure that we can compare boolean series in functions like Series.equal/2 . Fix rename of columns after summarise. Fix inspect of float series containing NaN or Infinity values. They are represented as atoms. Deprecated Deprecate DataFrame.filter/2 with a callback in favor of DataFrame.filter_with/2 .","ref":"changelog.html#v0-3-0-2022-09-01","title":"Changelog - v0.3.0 - 2022-09-01","type":"extras"},{"doc":"Added Consistently support ranges throughout the columns API Support negative indexes throughout the columns API Integrate with the table package Add Series.to_enum/1 for lazily traversing the series Add Series.coalesce/1 and Series.coalesce/2 for finding the first non-null value in a list of series Changed Series.length/1 is now Series.size/1 in keeping with Elixir idioms Nx is now an optional dependency Minimum Elixir version is now 1.13 DataFrame.to_map/2 is now DataFrame.to_columns/2 and DataFrame.to_series/2 Rustler is now an optional dependency read_ and write_ IO functions are now from_ and to_ to_binary is now dump_csv Now uses polars 's &quot;simd&quot; feature Now uses polars 's &quot;performant&quot; feature Explorer.default_backend/0 is now Explorer.Backend.get/0 Explorer.default_backend/1 is now Explorer.Backend.put/1 Series.cum_* functions are now Series.cumulative_* to mirror Nx Series.rolling_* functions are now Series.window_* to mirror Nx reverse? is now an option instead of an argument in Series.cumulative_* functions DataFrame.from_columns/2 and DataFrame.from_rows/2 is now DataFrame.new/2 Rename &quot;col&quot; to &quot;column&quot; throughout the API Remove &quot;with_&quot; prefix in options throughout the API DataFrame.table/2 accepts options with :limit instead of single integer rename/2 no longer accepts a function, use rename_with/2 instead rename_with/3 now expects the function as the last argument Fixed Explorer now works on Linux with musl","ref":"changelog.html#v0-2-0-2022-06-22","title":"Changelog - v0.2.0 - 2022-06-22","type":"extras"},{"doc":"Security Updated Rust dependencies to address Dependabot security alerts: 1 , 2 , 3","ref":"changelog.html#v0-1-1-2022-04-27","title":"Changelog - v0.1.1 - 2022-04-27","type":"extras"},{"doc":"First release.","ref":"changelog.html#v0-1-0-2022-04-26","title":"Changelog - v0.1.0 - 2022-04-26","type":"extras"}]